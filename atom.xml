<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Korea Developer Support Team Blog</title>
  
  <subtitle>개발기술지원팀의 블로그입니다.</subtitle>
  <link href="https://kocssds.github.io/atom.xml" rel="self"/>
  
  <link href="https://kocssds.github.io/"/>
  <updated>2021-12-21T01:07:01.271Z</updated>
  <id>https://kocssds.github.io/</id>
  
  <author>
    <name>Korea Developer Support Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Azure Boards 내에서 특정 이메일로의 Notification 방법</title>
    <link href="https://kocssds.github.io/2021/12/21/NotificationForAzureBoards/"/>
    <id>https://kocssds.github.io/2021/12/21/NotificationForAzureBoards/</id>
    <published>2021-12-21T00:59:18.000Z</published>
    <updated>2021-12-21T01:07:01.271Z</updated>
    
    <content type="html"><![CDATA[<p>간혹, Azure Boards를 사용하는 사용자에게 정의된 이메일 계정이 존재하지 않는 경우에도 대체할 수 있는 다른 이메일 계정이 존재한다면, 해당 이메일 계정으로 Notification이 가능합니다. 예를 들어, Azure Boards내에서 특정사용자에서 Work Item할당시 해당 사용자와 연관된 다른 이메일 계정으로 작업에 대한 알림을 보내기 위해 다음과 같이 설정할 수 있습니다. </p><p>특정 사용자의 Azure DevOps 사이트안에서 <strong>User Settings</strong> &gt; <strong>Notifications</strong>에 들어가시면, <strong>New subscription</strong>을 확인하실 수 있습니다.<br> <img src="/images/2021-12-21-10-01-24.png"></p><p>Category에 “<strong>Work</strong>”를 선택하고, 예를 들어 <strong>Template</strong>을 임의로 하나를 선택합니다.<br><img src="/images/2021-12-21-10-01-40.png"></p><p>아래의 화면에서 “<strong>Deliver to</strong>”에 “<strong>Other email</strong>”을 선택하고, “<strong>Address</strong>” 에 대체할 수 있는 이메일 계정을 선택하면 됩니다. 이후에 해당 사용자에게 Work Item이 할당이 된다면, 지정된 이메일 계정으로 메일이 전송됩니다.<br><img src="/images/2021-12-21-10-01-57.png"></p><p>관련해서는 문서 <a href="https://docs.microsoft.com/en-us/azure/devops/notifications/concepts-email-recipients?view=azure-devops">How notification email recipients are determined - Azure DevOps | Microsoft Docs</a> 문서를 참고할 수 있습니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;간혹, Azure Boards를 사용하는 사용자에게 정의된 이메일 계정이 존재하지 않는 경우에도 대체할 수 있는 다른 이메일 계정이 존재한다면, 해당 이메일 계정으로 Notification이 가능합니다. 예를 들어, Azure Boards내에서 </summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Azure Boards" scheme="https://kocssds.github.io/tags/Azure-Boards/"/>
    
    <category term="Notification" scheme="https://kocssds.github.io/tags/Notification/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps Agent를 systemd 서비스로 구동 시 No such file or directory 오류를 만날 수 있다</title>
    <link href="https://kocssds.github.io/2021/12/03/AzureDevOpsServiceAsSystemd/"/>
    <id>https://kocssds.github.io/2021/12/03/AzureDevOpsServiceAsSystemd/</id>
    <published>2021-12-03T04:57:46.000Z</published>
    <updated>2021-12-03T05:05:27.468Z</updated>
    
    <content type="html"><![CDATA[<p>Azure DevOps Pipeline Agent머신으로 Linux 머신을 사용할 때 실행되는 Agent 프로그램을 systemd 서비스로 구동 시킬 수 있습니다. 일반적인 경우에는 <a href="https://docs.microsoft.com/ko-kr/azure/devops/pipelines/agents/v2-linux?view=azure-devops#run-as-a-systemd-service">https://docs.microsoft.com/ko-kr/azure/devops/pipelines/agents/v2-linux?view=azure-devops#run-as-a-systemd-service</a> 문서 내용을 참고하여 systemd 서비스로의 설정에는 복잡한 문제가 있어 보이진 않습니다. 하지만, 흥미롭게도 아래와 같은 문제를 만날 수도 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[testadm@scselagentw1 azure-devops]$ sudo ./svc.sh status</span><br><span class="line">/etc/systemd/system/vsts.agent.testcorp.Default.scselagentw1.service</span><br><span class="line">● vsts.agent.testcorp.Default.scselagentw1.service - Azure Pipelines Agent (testcorp.Default.scselagentw1)</span><br><span class="line"></span><br><span class="line">   Loaded: loaded (/etc/systemd/system/vsts.agent.testcorp.Default.scselagentw1.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: exit-code) since Mon 2021-11-08 17:53:45 KST; 45s ago</span><br><span class="line">  Process: 1259 ExecStart=/agent/azure-devops/runsvc.sh (code=exited, status=200/CHDIR)</span><br><span class="line">Main PID: 1259 (code=exited, status=200/CHDIR)</span><br><span class="line"></span><br><span class="line">Nov 08 17:53:45 scselagentw1 systemd[1]: Started Azure Pipelines Agent (testcorp.Default.scselagentw1).</span><br><span class="line">Nov 08 17:53:45 scselagentw1 systemd[1259]: Failed at step CHDIR spawning /agent/azure-devops/runsvc.sh: No such file or directory</span><br><span class="line">Nov 08 17:53:45 scselagentw1 systemd[1]: vsts.agent.testcorp.Default.scselagentw1.service: main process exited, code=exit...0/CHDIR</span><br><span class="line">Nov 08 17:53:45 scselagentw1 systemd[1]: Unit vsts.agent.testcorp.Default.scselagentw1.service entered failed state.</span><br><span class="line">Nov 08 17:53:45 scselagentw1 systemd[1]: vsts.agent.testcorp.Default.scselagentw1.service failed.</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure><p>해당 문제가 흥미로운 이유는 오류메시지에 기인하여 관련된 서비스 파일등의 권한문제를 확인해 봤음에도 불구하고 별다른 권한 등의 문제가 존재하지 않는 다는 점입니다. 만일, 그렇다면 해당 agent가 설치된 폴더의 위치가 <a href="https://github.com/Azure/azure-storage-fuse">blobfuse</a>에 위치하는 지 확인해 보실 수 있습니다.<br>원인은 blobfuse file system이 mount되기 전에 Azure DevOps agent 서비스가 더 일찍 실행되는 경우가 발생할 수 있으며 이로 인하여 No such file or directory오류가 발생할 수 있기 때문입니다. 그러므로, 이와 같은 경우에는 agent 설치 위치를 blobfuse가 아닌 local 로 변경하여 해당 문제를 회피하는 것이 좋겠습니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Azure DevOps Pipeline Agent머신으로 Linux 머신을 사용할 때 실행되는 Agent 프로그램을 systemd 서비스로 구동 시킬 수 있습니다. 일반적인 경우에는 &lt;a href=&quot;https://docs.microsoft.com</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Linux" scheme="https://kocssds.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps와 사용자에 대한 흥미로운 몇 가지 의견들</title>
    <link href="https://kocssds.github.io/2021/11/03/ManageAzureDevOpsAndUsers/"/>
    <id>https://kocssds.github.io/2021/11/03/ManageAzureDevOpsAndUsers/</id>
    <published>2021-11-03T01:04:15.000Z</published>
    <updated>2021-11-03T01:27:18.976Z</updated>
    
    <content type="html"><![CDATA[<p>Azure DevOps 서비스에서는 사용자를 조직에 직접추가하고 관리할 수 있는 기능이 존재합니다. 이에 대해서 몇가지 흥미로운 아래와 같은 사실을 참고하실 수 있습니다.</p><ol><li><p>동일한 Email을 사용하여 Business 혹은 Personal account의 사용을 허용하더라도 사용하지 않는 것이 좋습니다.  </p><blockquote><p>We recommend using a different email or user principal name (UPN) for your personal and business accounts, rather than using the same, even though it’s allowed. This eliminates the challenge of disambiguating between your business and personal accounts when the email/UPN is the same. &lt;출처: <a href="https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/add-external-user?view=azure-devops&gt;">https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/add-external-user?view=azure-devops&gt;</a></p></blockquote></li><li><p>   Azure DevOps에 등록된 사용자에 대해서 기대하는 계정 타입으로의 변경(AAD 혹은 Personal)은 기존의 계정을 제거하고 다시 추가하는 방법을 통해서 가능합니다. Azure DevOps에서 계정 타입을 switch 할 수 있는 기능은 없습니다.</p></li><li><p>Azure DevOps Access Level을 Stakeholder에서 Basic으로 변경을 할 수 있는 권한주체 확인과 관련해서는 <strong>Project Collection Administrator</strong> 또는 <strong>Owner</strong>의 경우에 가능합니다. </p><blockquote><p>“For users tasked with managing organization or collection-level features —such as, projects, policies, processes, retention policies, agent and deployment pools, and extensions—add them to the Project Collection Administrators group.” &lt;출처: <a href="https://github.com/MicrosoftDocs/azure-devops-docs/blob/master/docs/organizations/security/set-project-collection-level-permissions.md&gt;">https://github.com/MicrosoftDocs/azure-devops-docs/blob/master/docs/organizations/security/set-project-collection-level-permissions.md&gt;</a></p></blockquote></li><li><p>   하나의 테넌트에 두개의 AAD 보안 그룹이 있고, 이 그룹이 각각 DevOps 조직을 소유하고 있습니다. 그 중 한 AAD 그룹에 사용자를 추가하면, Azure DevOps에 로그온이 되는 지에 대해서는 AAD에 사용자를 추가하더라도 Azure DevOps의 조직에 사용자를 직접 추가해야 합니다. 개념적으로 보면 Azure DevOps의 사용자는 AAD 사용자와 “매핑”이 되는 것이며, AAD에서 사용자를 추가/삭제한다고 해서 Azure DevOps에 자동으로 반영이 되지 않습니다. </p></li><li><p>   Azure DevOps 가 구독과 연계되어 생성되는 것인지에 대해서는 Azure DevOps는 파이프라인, 에이전트 풀 등에 추가 과금을 하거나 서비스 연결을 생성하기 위하여 구독을 설정하여 사용할 수 있으나 Azure DevOps가 구독을 연결해야만 생성되는 서비스는 아닙니다. 구독을 연결하지 않고도 서비스는 free tier로도 사용하실 수 있습니다. 그리고 Azure DevOps는 ‘조직’이라는 큰 단위에서 하위 팀 프로젝트들을 관리하는데, 여러 조직이 하나의 구독과 연결될 수 있습니다. 다시 말하자면, 구독과 서비스의 생성은 별개라고 할 수 있습니다. </p></li><li><p>   하나의 AAD 테넌트에서 하나의 DevOps 앱만 사용하는지, 생성시 이를 명시적으로 분할할 수 있는지에 대해서는 하나의 AAD 테넌트에서 Azure DevOps 앱은 분리가 되지 않습니다. Azure DevOps 앱을 두 개 만들어 조직에 각각 나눠지는 구조는 불가능합니다.</p></li><li><p>Azure DevOps 로그인을 할 때 사용자에 대한 특정 위치에서의 접근을 막고자 하는 목적이라면 AAD에서 제공하는 IP 기반으로 하는 조건부 액세스 정책을 고려해볼 수 있습니다.</p><blockquote><p>&lt;<a href="https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview#common-signals">https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview#common-signals</a><br>(Common signals &gt; IP Location information 부분 참고&gt;</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Azure DevOps 서비스에서는 사용자를 조직에 직접추가하고 관리할 수 있는 기능이 존재합니다. 이에 대해서 몇가지 흥미로운 아래와 같은 사실을 참고하실 수 있습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;동일한 Email을 사용하여 Business </summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Azure AD" scheme="https://kocssds.github.io/tags/Azure-AD/"/>
    
    <category term="MSA" scheme="https://kocssds.github.io/tags/MSA/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps에서의 Service Connection에 대해</title>
    <link href="https://kocssds.github.io/2021/10/15/MakeServiceConnectionForDevOps/"/>
    <id>https://kocssds.github.io/2021/10/15/MakeServiceConnectionForDevOps/</id>
    <published>2021-10-15T06:24:54.000Z</published>
    <updated>2021-10-15T08:45:37.501Z</updated>
    
    <content type="html"><![CDATA[<p>Azure DevOps Pipeline에서 Azure Resource를 사용하여 처리하기 위해서는 Azure Resource에 대한 접근 권한이 필요합니다. 실 예로 Azure Pipeline의 구성을 위해 임의의 Task을 추가하여 실행할 경우에 해당 Task를 실행 시 Azure Resource의 접근을 위해 Azure Subscription 정보를 입력하는 경우가 있는 데, 이에 해당하는 적절한 Service Connection을 생성하여 입력 처리하는 것이 일반적입니다. 이때 필요한 Service Connection은 다음과 같은 과정을 거쳐서 생성할 수 있습니다. </p><h3 id="Azure-DevOps-Service-Connection-추가"><a href="#Azure-DevOps-Service-Connection-추가" class="headerlink" title="Azure DevOps Service Connection 추가"></a><strong>Azure DevOps Service Connection 추가</strong></h3><ol><li>   Azure DevOps 포털에 로그인합니다. </li><li>   해당 Project의 Project settings에 들어갑니다.</li><li>   Service Connections에서 새로운 Service Connection을 생성합니다. </li><li>   New Service Connection에서 Azure Resource Manager를 선택합니다. </li><li>   Authentication Metod는 Service principal (automatic)을 선택한 후 다음을 누릅니다.</li><li>   Scope level은 Subscription으로 선택하고 하단의 Security는 “Grant access permission to all pipelines” 체크합니다.</li><li>   Subscription, Resource Group(기존에 생성한 Resource Group을 선택) 그리고, Service Connection 이름(예를 들어, ”AppConnection”)을 입력하고 저장합니다.</li></ol><p>정상적으로 Service Connection이 생성되면, AppConnection이라는 이름의 Service Connection이 생성이 되며, 이를 클릭하면 아래와 같은 메뉴를 확인할 수 있습니다. </p><ul><li>Manage Service Connection roles</li><li>Manage Service Principal</li></ul><p><img src="/images/2021-10-15-15-31-26.png"></p><h3 id="Manage-Service-Principal"><a href="#Manage-Service-Principal" class="headerlink" title="Manage Service Principal"></a><strong>Manage Service Principal</strong></h3><p>“Manage Service Principal”을 클릭하면, Azure 포털에 존재하는 Service Principal을 확인할 수 있는 데, 일반적으로 “조직이름-프로젝트이름-UUID” 형태의 이름을 가지고 있습니다. 해당 Service Principal의 좌측 메뉴에 Certificates $ secret을 확인해 보면, 기본적으로 Client secrets가 존재하고, 이에 대한 만료일이 지정되어 있기 때문에 이에 대해서는 반드시 확인하여 만료이후에 Azure Pipeline 처리에 문제가 되지 않도록 관리해야 합니다.<br>간혹 갱신 이후에 “Failed to obtain the Json Web Token(JWT) using service principal client ID. Exception message: AADSTS7000215: Invalid client secret is provided.” 이와 같은 오류가 발생할 수 있는 데, 이 경우에는 아래와 같은 단계를 통해서 문제를 피할 수 있습니다.</p><ol><li>   Service Connections에서 문제가 되는 Service Connection을 선택하고 Edit를 클릭합니다. </li><li>   Description(optional)을 수정하고 저장합니다. (Verify는 하지 마십시오.)</li><li>   Service Connection Edit 화면을 빠져나간 후에 해당 페이지를 refresh합니다. </li><li>   다시 Edit 화면으로 들어가서 Verify를 선택합니다. </li><li>   다시 저장 버튼을 클릭하여 저장합니다. </li></ol><h3 id="Manage-service-connection-roles"><a href="#Manage-service-connection-roles" class="headerlink" title="Manage service connection roles"></a><strong>Manage service connection roles</strong></h3><p>또한, “Manage service connection roles”를 클릭하면, Azure Portal로 이동하면서 해당 Service Principal 이 속한 Subscription 정보의 Access Control(IAM)를 확인할 수 있습니다. IAM의 role assignments 메뉴를 확인하면, Azure DevOps에서 등록된 Service Principal 이 “App” type의 <strong>Contributor Role</strong>로써 등록이 된 것으로 확인할 수 있습니다. </p><p>만일, 추가적인 권한이 필요하다면, </p><ol><li>   Add Role Assignment 메뉴로 들어가서 </li><li>   “Role”에 필요한 권한을 선택하고, </li><li>   “Assign access to”에 “user, group or service principal”을 선택, 그리고, “select”에 앞서서 생성한 Service Principal을 검색하여 선택하면, </li></ol><p>원하는 Role에 Azure DevOps에서 생성한 Service Principal을 추가할 수 있습니다. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Azure DevOps Pipeline에서 Azure Resource를 사용하여 처리하기 위해서는 Azure Resource에 대한 접근 권한이 필요합니다. 실 예로 Azure Pipeline의 구성을 위해 임의의 Task을 추가하여 실행할 경우</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Service Connection" scheme="https://kocssds.github.io/tags/Service-Connection/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps Service가 제공하는 Deployment Groups를 이용하여 Linux 머신에 Spring-Boot App을 배포하기</title>
    <link href="https://kocssds.github.io/2021/09/27/DeployAppUsingDeployGroups/"/>
    <id>https://kocssds.github.io/2021/09/27/DeployAppUsingDeployGroups/</id>
    <published>2021-09-27T00:47:05.000Z</published>
    <updated>2021-09-27T01:04:51.925Z</updated>
    
    <content type="html"><![CDATA[<p>Azure DevOps Service는 CI/CD 파이프라인 기능을 이용해 다양한 방법을 통해서 앱을 원하는 배포 머신에 배포할 수 있습니다. 그 중에서 Deployment Groups에 배포 머신을 등록하고 이를 이용하여 앱을 배포하는 방법에 대해서는 다음과 같은 절차를 통해서 접근해 보실 수 있습니다. </p><h3 id="Azure-DevOps-Repo의-구성"><a href="#Azure-DevOps-Repo의-구성" class="headerlink" title="Azure DevOps Repo의 구성"></a><strong>Azure DevOps Repo의 구성</strong></h3><ol><li>   Azure DevOps 포털에 로그온 합니다.</li><li>   New Project를 선택하여 새로운 Project를 생성합니다. </li><li>   생성된 Project로 들어가서 좌측의 Repos메뉴를 선택합니다. </li><li>   이후 Import a Repository 부분에서 사용하고자 하는 Spring Boot 예제를 import 하여 구성합니다. (예, <a href="https://github.com/spring-guides/gs-spring-boot.git">https://github.com/spring-guides/gs-spring-boot.git</a>  )</li></ol><h3 id="Azure-Build-Pipeline을-구성"><a href="#Azure-Build-Pipeline을-구성" class="headerlink" title="Azure Build Pipeline을 구성"></a><strong>Azure Build Pipeline을 구성</strong></h3><ol><li>   Pipelines에서 New Pipeline을 선택합니다. </li><li>   Azure Repos Git을 선택하여 이전 단계에서 구성한 Repo를 선택합니다. </li><li>   Configure your pipeline 단계에서는 Repo에 구성된 소스를 컴파일하기 위해 Maven (build your java project and run tests with Apache Maven)을 선택합니다. </li><li>   프로젝트 내에 azure-pipelines.yml 파일이 자동 생성되고, 아래와 같이 내용을 추가합니다.</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pool:</span></span><br><span class="line">  <span class="attr">vmImage:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">Maven@3</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">mavenPomFile:</span> <span class="string">&#x27;complete/pom.xml&#x27;</span></span><br><span class="line">    <span class="attr">mavenOptions:</span> <span class="string">&#x27;-Xmx3072m&#x27;</span></span><br><span class="line">    <span class="attr">javaHomeOption:</span> <span class="string">&#x27;JDKVersion&#x27;</span></span><br><span class="line">    <span class="attr">jdkVersionOption:</span> <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">    <span class="attr">jdkArchitectureOption:</span> <span class="string">&#x27;x64&#x27;</span></span><br><span class="line">    <span class="attr">publishJUnitResults:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testResultsFiles:</span> <span class="string">&#x27;**/surefire-reports/TEST-*.xml&#x27;</span></span><br><span class="line">    <span class="attr">goals:</span> <span class="string">&#x27;package&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">CopyFiles@2</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&#x27;Copy Files to: $(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">SourceFolder:</span> <span class="string">&#x27;$(system.defaultworkingdirectory)&#x27;</span></span><br><span class="line">    <span class="attr">Contents:</span> <span class="string">&#x27;**/*.?(jar|sh)&#x27;</span></span><br><span class="line">    <span class="attr">TargetFolder:</span> <span class="string">&#x27;$(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">    <span class="attr">flattenFolders:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">condition:</span> <span class="string">succeededOrFailed()</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">PublishBuildArtifacts@1</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">PathtoPublish:</span> <span class="string">&#x27;$(Build.ArtifactStagingDirectory)&#x27;</span></span><br><span class="line">    <span class="attr">ArtifactName:</span> <span class="string">&#x27;drop&#x27;</span></span><br><span class="line">    <span class="attr">publishLocation:</span> <span class="string">&#x27;Container&#x27;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>   빌드가 완료되면, Artifacts가 생성됩니다. 해당 Artifacts는 Azure Release Pipeline에서 download 받아서 처리될 예정입니다.</li></ol><h3 id="Deployment-Groups의-생성"><a href="#Deployment-Groups의-생성" class="headerlink" title="Deployment Groups의 생성"></a><strong>Deployment Groups의 생성</strong></h3><ol><li>   Azure Pipelines의 메뉴 중에 Deployment Groups를 선택하고, “New”을 클릭하여 생성합니다. </li><li>   “Deployment group name”에 임의의 이름 (예를 들면, ‘testdg’)을 입력하여 생성합니다. </li></ol><h3 id="Personal-Access-Token의-생성"><a href="#Personal-Access-Token의-생성" class="headerlink" title="Personal Access Token의 생성"></a><strong>Personal Access Token의 생성</strong></h3><ol><li>   Azure DevOps Portal에 로그온 후에 우측 상단에 User Settings메뉴가 존재하며, 이들 중 Personal Access Token 메뉴로 들어갑니다.</li><li>   New Token을 선택합니다. </li><li>   Name 과 Expiration Date를 원하는 내용으로 입력합니다.</li><li>   Scopes는 Custom defined를 선택하고, Show All Scopes를 클릭하여 확장합니다. </li><li>   리스트된 Scope 중에 Deployment Groups에 Read &amp; Manage 를 선택하여 생성합니다.</li><li>   이후 Personal Access Token을 Copy 하여 기억합니다. </li></ol><h3 id="Deployment-Groups에-포함될-Linux-VM의-생성"><a href="#Deployment-Groups에-포함될-Linux-VM의-생성" class="headerlink" title="Deployment Groups에 포함될 Linux VM의 생성"></a><strong>Deployment Groups에 포함될 Linux VM의 생성</strong></h3><ol><li>   Azure Portal에 로그온 합니다. </li><li>   Create a resource 를 통해서 Virtual Machine을 생성합니다. </li><li>   적절한 Subscription을 입력합니다. </li><li>   Resource Group에 Create New를 통해서 새롭게 생성합니다. </li><li>   Virtual machine name을 입력합니다. </li><li>   Region을 선택합니다. </li><li>   Image 를 선택합니다. (예를 들어, Ubuntu Server 18.04를 선택할 수 있습니다.)</li><li>   Size 를 선택합니다. (예를 들어, Standard D2s_V3 를 선택할 수 있습니다.)</li><li>   테스트 및 확인을 위해서 SSH (22)를 허용할 수 있습니다. </li><li>   Review + Create 를 통해서 생성합니다. </li></ol><h3 id="TeamServicesAgentLinux의-설치"><a href="#TeamServicesAgentLinux의-설치" class="headerlink" title="TeamServicesAgentLinux의 설치"></a><strong>TeamServicesAgentLinux의 설치</strong></h3><ol start="7"><li>   Azure Portal에서 앞서서 생성한 VM 리소스를 선택합니다. </li><li>   Settings에 Extensions를 선택합니다. </li><li>   +Add를 통해 “Azure Pipeline Agent For Linux”를 선택합니다. </li><li>   “Configure Azure Pipelines Agent For Linux Extension” 화면을 통해서 구성합니다. </li><li>   Azure DevOps Organization Url 에 기존에 생성한 Azure DevOps의 Project가 존재하는 조직을 포함하여 입력합니다. (예를 들어, <a href="https://dev.azure.com/organizationName&quot;">https://dev.azure.com/organizationName&quot;</a>)</li><li>   Team Project에 앞서서 구성한 Team Project의 이름을 입력합니다. </li><li>   Deployment Group에 앞서서 구성한 Deployment group name을 입력합니다. 이것은 앞서서 ‘Deployment Groups의 생성’ 단계에서 입력한 이름입니다. </li><li>   Personal Access Token에는 앞서서 ‘Personal Access Token의 생성’ 단계에서 복사한 값을 입력합니다.</li><li>   Review + Create를 통해 설치합니다. </li><li>   정상적으로 설치가 완료되면, Azure DevOps의 Deployment Groups에 생성한 Deployment Group (예를 들어, ‘Testdg’)을 선택하고, Targets를 확인하면, Healthy 상태의 VM이 등록된 것을 확인할 수 있습니다.</li></ol><h3 id="Release-Pipeline의-구성-및-실행"><a href="#Release-Pipeline의-구성-및-실행" class="headerlink" title="Release Pipeline의 구성 및 실행"></a><strong>Release Pipeline의 구성 및 실행</strong></h3><ol><li>   Azure DevOps 포털에서 Releases를 선택하고, 새로운 Release를 생성합니다. </li><li>   Add an Artifact를 통해서 Build Pipeline에서 설정된 Project와 Source를 선택한 후에 Add 합니다.</li><li>   Add a stage에서 Empty Job을 선택합니다.</li><li>   View Stage Task를 클릭합니다. </li><li>   새로운 Release Pipeline의 Tasks에 존재하는 Agent Job을 선택하고, 우측의 remove 버튼을 클릭하여 제거합니다. </li><li>   Add phase options를 클릭하여, add a deployment group job을 선택합니다. </li><li>   Deployment group job 에서 임의의 Name을 입력하고, Deployment targets의 Deployment group은 앞서서 생성한 Deployment Group을 선택합니다. (예를 들어, ‘testdg’)</li><li>   Add a task to Deployment Group Job (+ 메뉴)을 통해 Task를 추가합니다. Task는 ‘Bash’를 검색하여 추가합니다. </li><li>   Bash task 안에서 Type을 inline으로 선택하고 다음의 script 를 입력합니다.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /lib/artifacts/</span><br><span class="line">sudo cp $(System.DefaultWorkingDirectory)/_Test/drop/spring-boot-complete-0.0.1-SNAPSHOT.jar/lib/artifacts/</span><br><span class="line">sudo java -jar /lib/artifacts/spring-boot-complete-0.0.1-SNAPSHOT.jar &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li><li>   저장하고, release 를 생성한 후에 실행합니다. </li></ol><h3 id="테스트-및-확인-Linux-VM의-추가-Port-오픈"><a href="#테스트-및-확인-Linux-VM의-추가-Port-오픈" class="headerlink" title="테스트 및 확인 (Linux VM의 추가 Port 오픈)"></a><strong>테스트 및 확인 (Linux VM의 추가 Port 오픈)</strong></h3><ol><li>   Azure 포털에서 이전 단계에서 생성한 VM 환경으로 들어갑니다.</li><li>   Settings의 Networking메뉴를 선택하고, 이후 Add Inbound Port Rule을 선택합니다.</li><li>   Source Port range는 “*”, Destination Port는 “8080”, Source 와 Destination을 둘 다 Any로 선택하고, TCP에 대해서 “Allow”로써 추가합니다.</li><li>   이후 TCP 8080 포트가 오픈 됩니다.</li><li>   해당 VM의 public IP:8080 을 통해 Spring Boot App의 실행을 확인합니다.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Azure DevOps Service는 CI/CD 파이프라인 기능을 이용해 다양한 방법을 통해서 앱을 원하는 배포 머신에 배포할 수 있습니다. 그 중에서 Deployment Groups에 배포 머신을 등록하고 이를 이용하여 앱을 배포하는 방법에 </summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Linux" scheme="https://kocssds.github.io/tags/Linux/"/>
    
    <category term="QuickStart" scheme="https://kocssds.github.io/tags/QuickStart/"/>
    
    <category term="Deployment Groups" scheme="https://kocssds.github.io/tags/Deployment-Groups/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps Pipeline에서 Azure Image Builder를 이용하여 Spring Boot App을 Azure Virtual Machine Scale Set(VMSS)에 배포하기</title>
    <link href="https://kocssds.github.io/2021/08/25/DeployApptoVMSSusingImageBuilder/"/>
    <id>https://kocssds.github.io/2021/08/25/DeployApptoVMSSusingImageBuilder/</id>
    <published>2021-08-25T10:32:23.000Z</published>
    <updated>2021-08-25T11:19:12.328Z</updated>
    
    <content type="html"><![CDATA[<p>아래의 절차는 Azure DevOps에서 Azure Image Builder를 사용하는 과정을 참고하는 예제이며, 실제 업무상에 적용을 위해서는 많은 부분의 고려가 필요함을 미리 언급합니다. </p><p>Azure DevOps에서 ‘Build immutable image’ Task를 이용하면, 원하는 머신 이미지를 만들 수 있습니다. 이를 이용하여 몇몇 프로그램이 수행가능한 환경이 설치된 이미지를 생성할 수 있으며, 해당 이미지는 예를 들어 Azure VM Scale Set과 같은 환경의 인스턴스 생성에 이용할 수 있습니다. </p><p>먼저, java 실행 환경(Spring Boot 앱)이 포함된 머신 이미지를 생성하여, Azure 리소스 그룹에 포함시키는 과정은 아래와 같습니다. </p><h3 id="Azure-DevOps-Repo의-구성"><a href="#Azure-DevOps-Repo의-구성" class="headerlink" title="Azure DevOps Repo의 구성"></a><strong>Azure DevOps Repo의 구성</strong></h3><ol><li>   Azure DevOps 포털에 로그온 합니다.</li><li>   New Project를 선택하여 새로운 Project를 생성합니다. </li><li>   생성된 Project로 들어가서 좌측의 Repos메뉴를 선택합니다. </li><li>   이후 Import a Repository 부분에서 사용하고자 하는 Spring Boot 예제를 import 하여 구성합니다. (예, <a href="https://github.com/spring-guides/gs-spring-boot.git">https://github.com/spring-guides/gs-spring-boot.git</a>  )</li></ol><h3 id="Azure-DevOps-Service-Connection-추가"><a href="#Azure-DevOps-Service-Connection-추가" class="headerlink" title="Azure DevOps Service Connection 추가"></a><strong>Azure DevOps Service Connection 추가</strong></h3><ol><li>   이전 단계에서 생성된 Project의 Project settings에 들어갑니다.</li><li>   Service Connections에서 새로운 Service Connection을 생성합니다. </li><li>   New Service Connection에서 Azure Resource Manager를 선택합니다. </li><li>   Authentication Metod는 Service principal (automatic)을 선택한 후 다음을 누릅니다.</li><li>   Scope level은 Subscription으로 선택하고 Subscription, Resource Group(기존에 생성한 Resource Group을 선택) 그리고, Service Connection 이름을 입력하고 저장합니다.</li></ol><h3 id="Storage-Account의-생성"><a href="#Storage-Account의-생성" class="headerlink" title="Storage Account의 생성"></a><strong>Storage Account의 생성</strong></h3><ol><li>   Azure 포털에 로그온 합니다. </li><li>   좌측 메뉴에서 Create Resource를 선택합니다.</li><li>   찾기에서 Storage Account찾아 선택합니다. </li><li>   생성 시, 새로운 resource group을 만들고, 임의의 Storage Account의 이름을 입력한 후, 적당한 Region을 선택하여 생성합니다. </li></ol><h3 id="Shell-Script-파일의-추가"><a href="#Shell-Script-파일의-추가" class="headerlink" title="Shell Script 파일의 추가"></a><strong>Shell Script 파일의 추가</strong></h3><ol><li>   Azure DevOps 포털에 로그온 합니다. </li><li>   이전 단계에서 생성한 Project 내의 Repos의 Files로 이동합니다. </li><li>   기존의 소스 폴더에 deploy.sh라는 새로운 파일을 생성합니다.</li><li>   Deploy.sh 파일의 구성은 아래와 같습니다. <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">sudo apt-get update -y</span><br><span class="line">sudo apt-get install -y default-jre</span><br><span class="line">sudo mkdir /lib/artifacts/</span><br><span class="line">sudo cp /deployTemp/drop/*.jar /lib/artifacts/</span><br></pre></td></tr></table></figure></li></ol><ul><li>참고로.jar는 Build Pipeline을 통해서 생성될 바이너리입니다. </li><li>/deployTemp/drop/ 폴더의 위치는 Release Pipeline의 Build Immutable Image Task수행시 Artifacts가 이동될 위치입니다.</li></ul><h3 id="Azure-Build-Pipeline을-구성"><a href="#Azure-Build-Pipeline을-구성" class="headerlink" title="Azure Build Pipeline을 구성"></a><strong>Azure Build Pipeline을 구성</strong></h3><ol><li>   Pipelines에서 New Pipeline을 선택합니다. </li><li>   Azure Repos Git을 선택하여 이전 단계에서 구성한 Repo를 선택합니다. </li><li>   Configure your pipeline 단계에서는 Repo에 구성된 소스를 컴파일하기 위해 Maven (build your java project and run tests with Apache Maven)을 선택합니다. </li><li>   프로젝트 내에 azure-pipelines.yml 파일이 자동 생성되고, 아래와 같이 내용을 추가합니다.<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">trigger:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pool:</span></span><br><span class="line">  <span class="attr">vmImage:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">Maven@3</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">mavenPomFile:</span> <span class="string">&#x27;complete/pom.xml&#x27;</span></span><br><span class="line">    <span class="attr">mavenOptions:</span> <span class="string">&#x27;-Xmx3072m&#x27;</span></span><br><span class="line">    <span class="attr">javaHomeOption:</span> <span class="string">&#x27;JDKVersion&#x27;</span></span><br><span class="line">    <span class="attr">jdkVersionOption:</span> <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">    <span class="attr">jdkArchitectureOption:</span> <span class="string">&#x27;x64&#x27;</span></span><br><span class="line">    <span class="attr">publishJUnitResults:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testResultsFiles:</span> <span class="string">&#x27;**/surefire-reports/TEST-*.xml&#x27;</span></span><br><span class="line">    <span class="attr">goals:</span> <span class="string">&#x27;package&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">CopyFiles@2</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&#x27;Copy Files to: $(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">SourceFolder:</span> <span class="string">&#x27;$(system.defaultworkingdirectory)&#x27;</span></span><br><span class="line">    <span class="attr">Contents:</span> <span class="string">&#x27;**/*.?(jar|sh)&#x27;</span></span><br><span class="line">    <span class="attr">TargetFolder:</span> <span class="string">&#x27;$(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">    <span class="attr">flattenFolders:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">condition:</span> <span class="string">succeededOrFailed()</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">PublishBuildArtifacts@1</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">PathtoPublish:</span> <span class="string">&#x27;$(Build.ArtifactStagingDirectory)&#x27;</span></span><br><span class="line">    <span class="attr">ArtifactName:</span> <span class="string">&#x27;drop&#x27;</span></span><br><span class="line">    <span class="attr">publishLocation:</span> <span class="string">&#x27;Container&#x27;</span></span><br></pre></td></tr></table></figure></li><li>   빌드가 완료되면, Artifacts가 생성됩니다. 해당 Artifacts는 Azure Release Pipeline에서 download 받아서 처리될 예정입니다. </li></ol><h3 id="Azure-DevOps의-Release-Pipeline구성"><a href="#Azure-DevOps의-Release-Pipeline구성" class="headerlink" title="Azure DevOps의 Release Pipeline구성"></a><strong>Azure DevOps의 Release Pipeline구성</strong></h3><ol><li>   Azure DevOps 포털에 로그온 합니다.</li><li>   해당 Project로 들어가서 좌측의 Release 메뉴를 선택합니다. 이후 New Pipeline을 생성합니다. </li><li>   Empty Job을 선택합니다. </li><li>   Agent Job에서 Agent Specification을 ubuntu-18.04 로 선택합니다.</li><li>   Agent Job에 Build Immutable Image task를 추가합니다. </li></ol><ul><li>   적당한 Display Name을 입력합니다.</li><li>   Packer template 은 “Auto generated”로 선택합니다.</li><li>Azure subscription을 선택합니다. </li><li>Managed VM Disk image의 체크 박스를 체크하고, Name을 입력합니다. (해당 이름으로 Azure 리소스 그룹에 이미지가 생성됩니다.)</li><li>   Storage location에 적절한 region을 지정합니다.</li><li>   Storage account에 앞서서 생성한 storage account를 선택합니다.</li><li>   Resource Group에는 Storage account와 동일한 Resource group을 선택합니다.</li><li>   Base image source는 “Gallery”로 선택합니다. </li><li>   Base image는 “ubuntu 18.04-LTS”를 선택합니다. </li><li>   Deployment Package는 일반적으로 Artifacts가 생성된 위치를 지정합니다. (일반적으로 $(System.DefaultWorkingDirectory)에 대한 상대적인 위치인데, _&lt;project 이름&gt;/drop이라는 형태를 갖습니다.)</li><li>   Deployment script는 앞서서 생성한 script 파일을 입력합니다. (Build pipeline에서 .sh파일도 artifacts에 포함했으므로 해당 파일 이름을 입력합니다.)</li></ul><ol start="6"><li>   설정을 마치면, YAML 파일로는 아래와 같이 구성됩니다. <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">PackerBuild@1</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&#x27;Build immutable image&#x27;</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">ConnectedServiceName:</span> <span class="string">‘&lt;service</span> <span class="string">connection&gt;&#x27;</span></span><br><span class="line">    <span class="attr">managedImageName:</span> <span class="string">myvmssimage2</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">koreasouth</span></span><br><span class="line">    <span class="attr">storageAccountName:</span> <span class="string">myvmssstorage</span></span><br><span class="line">    <span class="attr">azureResourceGroup:</span> <span class="string">&#x27;vmss_rg&#x27;</span></span><br><span class="line">    <span class="attr">baseImage:</span> <span class="string">&#x27;Canonical:UbuntuServer:18.04-LTS:linux&#x27;</span></span><br><span class="line">    <span class="attr">packagePath:</span> <span class="string">&#x27;_vmsstest/drop&#x27;</span></span><br><span class="line">    <span class="attr">deployScriptPath:</span> <span class="string">deploy.sh</span></span><br></pre></td></tr></table></figure></li><li>   Build Pipepline과 Release Pipeline이 정상적으로 run 된다면, ‘vmss_rg’ 라는 Azure 리소스 그룹내에 myvmssstorage 라는 storage account 와 myvmssimage2 라는 이름이 image가 생성된 것으로 확인할 수 있습니다. </li><li>   해당 머신 이미지안에는 Java 실행환경과 build Pipeline을 통해 만들어진 spring boot 앱이 포함되어 있습니다. 그러므로, 해당 머신 이미지를 기반으로 Azure VM Scale Set 인스턴스를 구성할 수 있습니다. </li></ol><h3 id="Azure-Virtual-Machine-Scale-Set에-이미지-업데이트"><a href="#Azure-Virtual-Machine-Scale-Set에-이미지-업데이트" class="headerlink" title="Azure Virtual Machine Scale Set에 이미지 업데이트"></a><strong>Azure Virtual Machine Scale Set에 이미지 업데이트</strong></h3><ol><li>   앞서서 생성한 머신 이미지를 이용하여 만들어진 Azure VM Scale Set 인스턴스에 포함된 Spring Boot 앱의 업데이트가 필요하다면, 앞선 절차의 Build/Release Pipeline을 통해서 머신 이미지를 다시 생성할 수 있으며 이를 기존의 Azure VM Scale Set의 인스턴스에 업데이트 해야 합니다.</li><li>   기존의 절차에 따라 새롭게 생성된 머신 이미지를 기존의 Azure VM Scale Set 인스턴스에 업데이트를 하기 위해 Release Pipeline에 Azure CLI Task를 추가합니다. </li></ol><ul><li>Azure CLI Task를 추가합니다.</li><li>   Azure Resource Manager Connection에 기존의 생성된 머신 이미지가 존재하는 Azure 리소스 그룹에 접근이 가능하도록 선택합니다. </li><li>   Script Type은 shell을 선택합니다.</li><li>   Script location은 inline Script를 선택합니다. </li><li>   Inline script에 아래를 추가합니다. (‘vms’는 VMSS의 이름, ‘vmss_rg’는 VMSS가 존재하는 resource group)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vmss update --name vms --resource-group vmss_rg --set virtualMachineProfile.storageProfile.imageReference.id=&quot;/subscriptions/&lt;subcscription-Id&gt;/resourceGroups/vmss_rg/providers/Microsoft.Compute/images/&lt;managed image name&gt;&quot;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>   새롭게 배포된 spring boot 앱을 이미지 업데이트 이후에 즉시 실행해야 한다면, 추가적으로 Azure CLI Task를 이용하여 원격에서 구동할 수 있습니다. </li></ol><ul><li>Azure CLI Task를 추가합니다. </li><li>앞선 Azure CLI task의 작업과 동일하며, inline script에 아래와 같이 다르게 입력합니다. <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vmss list-instances -n vms -g vmss_rg --query <span class="string">&quot;[].id&quot;</span> --output tsv | az vmss run-command invoke --scripts <span class="string">&quot;java -jar /lib/artifacts/spring-boot-complete-0.0.1-SNAPSHOT.jar &gt;/dev/null 2&gt;&amp;1 &amp;&quot;</span>  --command-id RunShellScript --ids @-</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>   모든 Pipeline이 정상적으로 실행 완료가 되면 새롭게 배포된 spring boot앱이 VMSS에 정상적으로 실행되는 지 확인하십시오.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;아래의 절차는 Azure DevOps에서 Azure Image Builder를 사용하는 과정을 참고하는 예제이며, 실제 업무상에 적용을 위해서는 많은 부분의 고려가 필요함을 미리 언급합니다. &lt;/p&gt;
&lt;p&gt;Azure DevOps에서 ‘Build </summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="QuickStart" scheme="https://kocssds.github.io/tags/QuickStart/"/>
    
    <category term="VMSS" scheme="https://kocssds.github.io/tags/VMSS/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps를 이용하여 Spring Boot 앱을 Linux VM에 배포하기</title>
    <link href="https://kocssds.github.io/2021/07/27/DeployAppToLinuxVM/"/>
    <id>https://kocssds.github.io/2021/07/27/DeployAppToLinuxVM/</id>
    <published>2021-07-27T12:37:58.000Z</published>
    <updated>2021-07-27T12:51:21.169Z</updated>
    
    <content type="html"><![CDATA[<p>다음은 Azure DevOps Pipeline을 이용하여 Spring Boot App을 Linux VM에 배포하는 시나리오의 예제입니다. Linux VM은 Azure DevOps의 Environments에 등록하여 구성합니다.</p><h3 id="Azure-환경에서-Linux-VM-생성"><a href="#Azure-환경에서-Linux-VM-생성" class="headerlink" title="Azure 환경에서 Linux VM 생성"></a><strong>Azure 환경에서 Linux VM 생성</strong></h3><ol><li>   Azure 포털에 로그온 합니다. </li><li>   좌측 메뉴에서 Create a resource에서 Virtual Machine을 생성합니다. </li><li>   Resource Group, Region그리고, Virtual Machine Name을 입력합니다. </li><li>   Image는 Ubuntu Server 18.04 LTS를 선택합니다. </li><li>   Inbound port rules에서 SSH(22) 포트를 오픈합니다. </li><li>   Review+Create를 통해 Linux VM을 생성합니다. </li><li>   생성시에 SSH key (.pem 파일)을 download 하는 데, 적당한 local folder에 저장합니다. 해당 키를 가지고, 해당 VM에 SSH로 접근할 수 있습니다. </li></ol><h3 id="Azure-DevOps-Repo의-구성"><a href="#Azure-DevOps-Repo의-구성" class="headerlink" title="Azure DevOps Repo의 구성"></a><strong>Azure DevOps Repo의 구성</strong></h3><ol><li>   Azure DevOps 포털에 로그온 합니다.</li><li>   New Project를 선택하여 새로운 Project를 생성합니다. </li><li>   생성된 Project로 들어가서 좌측의 Repos메뉴를 선택합니다. </li><li>   이후 Import a Repository 부분에서 사용하고자 하는 Spring Boot 예제를 import 하여 구성합니다. (예, <a href="https://github.com/spring-guides/gs-spring-boot.git">https://github.com/spring-guides/gs-spring-boot.git</a>  )</li></ol><h3 id="Azure-DevOps의-Environments에-Linux-VM-추가"><a href="#Azure-DevOps의-Environments에-Linux-VM-추가" class="headerlink" title="Azure DevOps의 Environments에 Linux VM 추가"></a><strong>Azure DevOps의 Environments에 Linux VM 추가</strong></h3><ol><li>   Azure DevOps 포털에 로그온 합니다. </li><li>   기 생성된 Project의 좌측 메뉴에서 Pipelines 하위의 Environments를 선택합니다. </li><li>   New environment를 선택합니다. </li><li>   New environment에서 Name(예, “linuxVM”)을 입력하여 Resource는 Virtual Machines를 선택합니다. </li><li>   Virtual machine resource에서 Provider는 Generic provider를 선택하고, OS는 Linux를 선택한 후 Registration script를 copy 합니다.</li><li>   앞서서 생성한 Linux VM에 SSH로 로그온 합니다. </li><li>   5번에서 copy 한 script를 paste 하여 실행합니다. </li><li>   정상적으로 script가 실행이 되었다면, Azure DevOps Environments에 4번에서 입력한 Name (예, “linuxVM”)으로 등록이 됩니다.</li><li>   추가적으로 SSH로 VM에 로그온 된 상태에서 “/lib/artifacts/” 폴더를 생성합니다. (해당 폴더는 Azure Pipeline을 통해서 배포된 Artifacts (jar 파일)를 copy 할 대상 폴더로 사용할 예정입니다.)</li><li>   Spring Boot App실행을 위해 Java Runtime Environment(JRE)를 설치합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y default-jre</span><br></pre></td></tr></table></figure></li></ol><h3 id="Linux-VM에서-추가-Port-오픈"><a href="#Linux-VM에서-추가-Port-오픈" class="headerlink" title="Linux VM에서 추가 Port 오픈"></a><strong>Linux VM에서 추가 Port 오픈</strong></h3><ol><li>   Azure 포털에서 이전 단계에서 생성한 VM 환경으로 들어갑니다.</li><li>   Settings의 Networking메뉴를 선택하고, 이후 Add Inbound Port Rule을 선택합니다.</li><li>   Source Port range는 “*”, Destination Port는 “8080”, Source 와 Destination을 둘 다 Any로 선택하고, TCP에 대해서 “Allow”로써 추가합니다.</li><li>   이후 TCP 8080 포트가 오픈 됩니다.</li></ol><h3 id="Azure-Pipeline의-구성"><a href="#Azure-Pipeline의-구성" class="headerlink" title="Azure Pipeline의 구성"></a><strong>Azure Pipeline의 구성</strong></h3><ol><li>   Environments에 Linux VM이 추가가 되었다면 다시 pipelines에서 New Pipeline을 선택합니다. </li><li>   Azure Repos Git을 선택하여 이전 단계에서 구성한 Repo를 선택합니다. </li><li>   Configure your pipeline 단계에서는 Repo에 구성된 소스를 컴파일하기 위해 Maven (build your java project and run tests with Apache Maven)을 선택합니다. </li><li>   프로젝트 내에 azure-pipelines.yml 파일이 자동 생성되고, 아래와 같이 내용을 추가합니다.<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">trigger:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pool:</span></span><br><span class="line">  <span class="attr">vmImage:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">stage:</span> <span class="string">Build</span></span><br><span class="line">    <span class="attr">displayName:</span> <span class="string">Build</span> <span class="string">Stage</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">displayName:</span> <span class="string">Build</span> <span class="string">Maven</span> <span class="string">Project</span></span><br><span class="line">        <span class="attr">steps:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">Maven@3</span></span><br><span class="line">            <span class="attr">displayName:</span> <span class="string">&#x27;Maven Package&#x27;</span></span><br><span class="line">            <span class="attr">inputs:</span></span><br><span class="line">              <span class="attr">mavenPomFile:</span> <span class="string">&#x27;complete/pom.xml&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">CopyFiles@2</span></span><br><span class="line">            <span class="attr">displayName:</span> <span class="string">&#x27;Copy Files to artifact staging directory&#x27;</span></span><br><span class="line">            <span class="attr">inputs:</span></span><br><span class="line">              <span class="attr">SourceFolder:</span> <span class="string">&#x27;$(System.DefaultWorkingDirectory)&#x27;</span></span><br><span class="line">              <span class="attr">Contents:</span> <span class="string">&#x27;**/target/*.?(war|jar)&#x27;</span></span><br><span class="line">              <span class="attr">TargetFolder:</span> <span class="string">$(Build.ArtifactStagingDirectory)</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">upload:</span> <span class="string">$(Build.ArtifactStagingDirectory)</span></span><br><span class="line">            <span class="attr">artifact:</span> <span class="string">drop</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">deployment:</span> <span class="string">DeployWeb</span></span><br><span class="line">      <span class="attr">displayName:</span> <span class="string">deploy</span> <span class="string">Web</span> <span class="string">App</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">vmImage:</span> <span class="string">&#x27;Ubuntu-latest&#x27;</span></span><br><span class="line">      <span class="comment"># creates an environment if it doesn&#x27;t exist</span></span><br><span class="line">      <span class="attr">environment:</span> </span><br><span class="line">       <span class="attr">name:</span> <span class="string">&#x27;linuxVM&#x27;</span></span><br><span class="line">       <span class="attr">resourceType:</span> <span class="string">VirtualMachine</span></span><br><span class="line">      <span class="attr">strategy:</span>        </span><br><span class="line">        <span class="attr">runOnce:</span></span><br><span class="line">          <span class="attr">deploy:</span></span><br><span class="line">            <span class="attr">steps:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">                sudo cp $(Pipeline.Workspace)/drop/**/target/*.jar /lib/artifacts/</span></span><br><span class="line"><span class="string">                sudo java -jar /lib/artifacts/*.jar &gt;/dev/null 2&gt;&amp;1 &amp;</span></span><br></pre></td></tr></table></figure></li><li>   Run 합니다. </li><li>   정상적으로 Azure Pipeline이 처리가 되었다면, Linux VM의 Public Ip를 통해 실행 중인 Spring Boot App을 접근할 수 있습니다. </li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;다음은 Azure DevOps Pipeline을 이용하여 Spring Boot App을 Linux VM에 배포하는 시나리오의 예제입니다. Linux VM은 Azure DevOps의 Environments에 등록하여 구성합니다.&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Linux" scheme="https://kocssds.github.io/tags/Linux/"/>
    
    <category term="QuickStart" scheme="https://kocssds.github.io/tags/QuickStart/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps를 이용하여 Spring Boot 앱을 Azure Virtual Machine Scale Set(VMSS)에 배포하기</title>
    <link href="https://kocssds.github.io/2021/07/22/DeployApptoVMSS/"/>
    <id>https://kocssds.github.io/2021/07/22/DeployApptoVMSS/</id>
    <published>2021-07-22T06:17:58.000Z</published>
    <updated>2021-07-22T07:05:44.118Z</updated>
    
    <content type="html"><![CDATA[<p>다음은 Azure DevOps Pipeline을 이용하여 간단한 Spring Boot 앱을 빌드하여 Azure Blob Storage에 배포한 후에 Custom Script Extension을 이용하여 VMSS에 해당 앱을 설치하는 과정을 단계별로 실습해 볼 수 있습니다. 아래의 단계는 업무에 사용될 수 있는 완벽한 예제는 아니며, VMSS에 Java 앱을 배포하는 여러가지 방법 중에 한가지 아이디어로써 참고하실 수 있습니다.</p><h3 id="Storage-Account의-생성"><a href="#Storage-Account의-생성" class="headerlink" title="Storage Account의 생성"></a><strong>Storage Account의 생성</strong></h3><hr><ol><li>   Azure 포털에 로그온 합니다. </li><li>   좌측 메뉴에서 Create Resource를 선택합니다.</li><li>   찾기에서 Storage Account찾아 선택합니다. </li><li>   생성 시, 새로운 resource group을 만들고, 임의의 Storage Account의 이름을 입력한 후, 적당한 Region을 선택하여 생성합니다. </li><li>   생성이 완료된 후, Storage Account로 들어가서 새로운 container를 추가합니다. </li><li>   Container 생성시, Public Access Level을 Blob으로 선택하여 생성합니다. </li></ol><h3 id="Azure-DevOps-Repo의-구성"><a href="#Azure-DevOps-Repo의-구성" class="headerlink" title="Azure DevOps Repo의 구성"></a><strong>Azure DevOps Repo의 구성</strong></h3><hr><ol><li>   Azure DevOps 포털에 로그온 합니다.</li><li>   New Project를 선택하여 새로운 Project를 생성합니다. </li><li>   생성된 Project로 들어가서 좌측의 Repos메뉴를 선택합니다. </li><li>   이후 Import a Repository 부분에서 사용하고자 하는 Spring Boot 예제를 import 하여 구성합니다. (예, <a href="https://github.com/spring-guides/gs-spring-boot.git">https://github.com/spring-guides/gs-spring-boot.git</a>  )</li></ol><h3 id="Azure-DevOps-Service-Connection-추가"><a href="#Azure-DevOps-Service-Connection-추가" class="headerlink" title="Azure DevOps Service Connection 추가"></a><strong>Azure DevOps Service Connection 추가</strong></h3><hr><ol><li>   이전 단계에서 생성된 Project의 Project settings에 들어갑니다.</li><li>   Service Connections에서 새로운 Service Connection을 생성합니다. </li><li>   New Service Connection에서 Azure Resource Manager를 선택합니다. </li><li>   Authentication Metod는 Service principal (automatic)을 선택한 후 다음을 누릅니다.</li><li>   Scope level은 Subscription으로 선택하고 Subscription, Resource Group(기존에 생성한 Resource Group을 선택) 그리고, Service Connection 이름을 입력하고 저장합니다.</li></ol><h3 id="Azure-DevOps-Pipeline의-구성"><a href="#Azure-DevOps-Pipeline의-구성" class="headerlink" title="Azure DevOps Pipeline의 구성"></a><strong>Azure DevOps Pipeline의 구성</strong></h3><hr><ol><li>   Project내에서Pipelines를 선택하고 Create Pipeline을 선택합니다.</li><li>   Azure Repos Git을 선택하여 이전 단계에서 구성한 Repo를 선택합니다. </li><li>   Configure your pipeline 단계에서는 Repo에 구성된 소스를 컴파일하기 위해 Maven (build your java project and run tests with Apache Maven)을 선택합니다. </li><li>   프로젝트 내에 azure-pipelines.yml 파일이 자동 생성되고, 아래와 같이 내용을 추가합니다.<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">trigger:</span></span><br><span class="line"><span class="bullet">-</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pool:</span></span><br><span class="line">  <span class="attr">vmImage:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">Maven@3</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">mavenPomFile:</span> <span class="string">&#x27;pom.xml&#x27;</span></span><br><span class="line">    <span class="attr">mavenOptions:</span> <span class="string">&#x27;-Xmx3072m&#x27;</span></span><br><span class="line">    <span class="attr">javaHomeOption:</span> <span class="string">&#x27;JDKVersion&#x27;</span></span><br><span class="line">    <span class="attr">jdkVersionOption:</span> <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">    <span class="attr">jdkArchitectureOption:</span> <span class="string">&#x27;x64&#x27;</span></span><br><span class="line">    <span class="attr">publishJUnitResults:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testResultsFiles:</span> <span class="string">&#x27;**/surefire-reports/TEST-*.xml&#x27;</span></span><br><span class="line">    <span class="attr">goals:</span> <span class="string">&#x27;package&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">CopyFiles@2</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&#x27;Copy Files to: $(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">SourceFolder:</span> <span class="string">&#x27;$(system.defaultworkingdirectory)&#x27;</span></span><br><span class="line">    <span class="attr">Contents:</span> <span class="string">&#x27;**/*.?(jar|sh)&#x27;</span></span><br><span class="line">    <span class="attr">TargetFolder:</span> <span class="string">&#x27;$(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">    <span class="attr">flattenFolders:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">condition:</span> <span class="string">succeededOrFailed()</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">PublishBuildArtifacts@1</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&#x27;Publish Artifact: drop&#x27;</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">PathtoPublish:</span> <span class="string">&#x27;$(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">condition:</span> <span class="string">succeededOrFailed()</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">AzureCLI@2</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&#x27;Azure CLI &#x27;</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">azureSubscription:</span> <span class="string">&#x27;$(AZURE_SUBSCRIPTION)&#x27;</span></span><br><span class="line">    <span class="attr">scriptType:</span> <span class="string">bash</span></span><br><span class="line">    <span class="attr">scriptLocation:</span> <span class="string">inlineScript</span></span><br><span class="line">    <span class="attr">inlineScript:</span> <span class="string">&#x27;az storage blob upload-batch --destination artifacts --source $(build.artifactstagingdirectory) --account-name $AZURE_STORAGE_ACCOUNT&#x27;</span></span><br></pre></td></tr></table></figure></li><li>   Maven에 의해서 생성된 Task 외에 Copy Files, Publish Build Artifacts, 그리고, Azure CLI task를 차례로 추가합니다. 특히, Azure CLI task에서는 Maven Task에서 생성된 Artifacts를 지정된 Azure Blob Storage에 업로드를 합니다. </li><li>   Variables에 AZURE_SUBSCRIPTION과 AZURE_STORAGE_ACCOUNT를 추가하고, 앞서서 추가한 Service Connection과 Storage Account이름을 값으로 각각 입력합니다. </li><li>   Run합니다. </li><li>   문제가 없다면, Maven을 통해 생성된 (예를 들어, spring-boot-0.0.1-SNAPSHOT.jar) jar 파일이 지정된 Blob Storage에 업로드가 됩니다. </li></ol><h3 id="Shell-Script-파일의-추가"><a href="#Shell-Script-파일의-추가" class="headerlink" title="Shell Script 파일의 추가"></a><strong>Shell Script 파일의 추가</strong></h3><hr><ol><li>   Azure DevOps 포털에 로그온 합니다. </li><li>   이전 단계에서 생성한 Project 내의 Repos의 Files로 이동합니다. </li><li>   기존의 소스 폴더에 Shell Script 파일(.sh 파일)을 생성합니다.</li><li>   아래와 같이 내용을 추가합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">sudo apt-get update -y</span><br><span class="line">sudo apt-get install -y default-jre</span><br><span class="line">java -jar spring-boot-0.0.1-SNAPSHOT.jar &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li><li>   저장한 후 다시 build Pipeline을 Run 합니다.</li><li>   문제가 없다면, 지정된 Azure Blob Storage에 jar 파일과 더불어 .sh 파일이 업로드가 됩니다.</li></ol><h3 id="Azure-Virtual-Machine-Scale-Set-VMSS-의-구성"><a href="#Azure-Virtual-Machine-Scale-Set-VMSS-의-구성" class="headerlink" title="Azure Virtual Machine Scale Set (VMSS)의 구성"></a><strong>Azure Virtual Machine Scale Set (VMSS)의 구성</strong></h3><hr><ol><li>   Azure 포털에 로그온 합니다.</li><li>   좌측 메뉴에서 Create resource를 선택합니다.</li><li>   찾기 메뉴에서 Virtual Machine Scale Set을 찾아 선택합니다. </li><li>   생성시 기존에 생성한 Storage Account와 동일한 Resource Group을 선택합니다. </li><li>   Virtual Machine Scale Set name을 입력하고, Resource Group이 위치한 Region을 선택합니다. </li><li>   Ubuntu Server 20.04 LTS를 선택합니다. </li><li>   Networking에서 “Edit Network Interface”을 클릭하고, (간단한 Spring Boot 예제의 실행 테스트를 위해서) Public Ip Address를 enable 한 후 OK를 누릅니다. </li><li>   Management에서 Upgrade Policy는 Automatic으로 선택합니다.</li><li>   Review+Create를 선택하여 VMSS를 생성합니다. </li></ol><h3 id="Azure-Virtual-Machine-Scale-Set-VMSS-Port-오픈"><a href="#Azure-Virtual-Machine-Scale-Set-VMSS-Port-오픈" class="headerlink" title="Azure Virtual Machine Scale Set (VMSS) Port 오픈"></a><strong>Azure Virtual Machine Scale Set (VMSS) Port 오픈</strong></h3><hr><ol><li>   Azure 포털에서 이전 단계에서 생성한 VMSS 환경으로 들어갑니다.</li><li>   Settings의 Networking메뉴를 선택하고, 이후 Add Inbound Port Rule을 선택합니다.</li><li>   Source Port range는 “*”, Destination Port는 “8080”, Source 와 Destination을 둘 다 Any로 선택하고, TCP에 대해서 “Allow”로써 추가합니다.</li><li>   이후 TCP 8080 포트가 오픈됩니다.</li></ol><h3 id="Azure-DevOps의-Release-Pipeline구성"><a href="#Azure-DevOps의-Release-Pipeline구성" class="headerlink" title="Azure DevOps의 Release Pipeline구성"></a><strong>Azure DevOps의 Release Pipeline구성</strong></h3><hr><ol><li>   Azure DevOps 포털에 로그온 합니다.</li><li>   해당 Project로 들어가서 좌측의 Release 메뉴를 선택합니다. 이후 New Pipeline을 생성합니다. </li><li>   Empty Job을 선택합니다. </li><li>   Agent Job에서 Agent Specification을 ubuntu-20.04 로 선택합니다.</li><li>   Agent Job에 Azure CLI task를 추가합니다. </li><li>   Azure CLI task에서 Azure Resource Manager Connection은 이전 단계에서 생성한 Service Connection을 선택합니다. </li><li>   Script Type은Shell 로 선택합니다. </li><li>   Script Location은 inline script로 선택하고, 아래의 script를 추가합니다. <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vmss extension set --resource-group vmss_rg --vmss-name vmssmachines --name customScript --publisher Microsoft.Azure.Extensions --version 2.0 --extension-instance-name JarExt --settings &#x27;&#123;&quot;fileUris&quot;: [&quot;https://myvmssstorage.blob.core.windows.net/artifacts/deploy.sh&quot;, &quot;https://myvmssstorage.blob.core.windows.net/artifacts/spring-boot-0.0.1-SNAPSHOT.jar&quot;],&quot;commandToExecute&quot;: &quot;./deploy.sh&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure></li><li>   Create Release를 통해 deploy를 합니다. </li><li>   이전 Build Pipeline을 통해 업로드가 된 jar 파일과 shell script로 구성된 <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/extensions/custom-script-linux">Custom Script Extension</a>이 지정된 VMSS에 설치가 되고 Automatic Upgrade Policy에 의해 자동 업데이트가 됩니다.</li><li>   정상적으로 설치가 완료되면, VMSS에서 관리 중인 임의의 VM에 대한 지정된 Public IP와 8080 port를 이용해 Spring Boot 앱에 접근 테스트를 합니다. </li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;다음은 Azure DevOps Pipeline을 이용하여 간단한 Spring Boot 앱을 빌드하여 Azure Blob Storage에 배포한 후에 Custom Script Extension을 이용하여 VMSS에 해당 앱을 설치하는 과정을 단계별</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="QuickStart" scheme="https://kocssds.github.io/tags/QuickStart/"/>
    
    <category term="VMSS" scheme="https://kocssds.github.io/tags/VMSS/"/>
    
  </entry>
  
  <entry>
    <title>Azure Pipeline에서의 로그 확인</title>
    <link href="https://kocssds.github.io/2021/07/14/AzureDevOpsLogExtract/"/>
    <id>https://kocssds.github.io/2021/07/14/AzureDevOpsLogExtract/</id>
    <published>2021-07-14T05:10:37.000Z</published>
    <updated>2021-07-22T06:45:29.308Z</updated>
    
    <content type="html"><![CDATA[<p>Azure DevOps Pipeline에서 실패가 보고된다면, 가장 먼저 확인해야 하는 부분은 로그 부분일 것이다. </p><p><img src="/images/2021-07-14-14-19-10.png"></p><p>실패한 파이프라인을 클릭하고, 확인하고자 원하는 시간에 수행된 Build Pipeline을 선택하여 클릭한다.</p><p><img src="/images/2021-07-14-14-21-44.png"></p><p>그리고, 우측상단의 풀다운 메뉴를 크릭하면, 문제가 발생한 시점의 빌드 로그를 다운로드 받을 수 있다.</p><p><img src="/images/2021-07-14-14-23-39.png"></p><p>만일, Azure DevOps 측면에서 좀 더 자세한 로그 정보를 확인하길 원한다면, Build Pipeline의 Variables에 System.Debug 를 true로 설정하고 빌드를 시도한다면, 좀 더 자세한 로그를 출력할 수 있다. </p><p><img src="/images/2021-07-14-14-29-46.png"></p><p>더 많은 정보 확인: <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/troubleshooting/review-logs?view=azure-devops">Review logs to diagnose pipeline issues</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Azure DevOps Pipeline에서 실패가 보고된다면, 가장 먼저 확인해야 하는 부분은 로그 부분일 것이다. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2021-07-14-14-19-10.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;실패한 파이프라인을 클릭</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Build Pipeline" scheme="https://kocssds.github.io/tags/Build-Pipeline/"/>
    
  </entry>
  
</feed>
