<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Korea Developer Support Team Blog</title>
  
  <subtitle>개발기술지원팀의 블로그입니다.</subtitle>
  <link href="https://kocssds.github.io/atom.xml" rel="self"/>
  
  <link href="https://kocssds.github.io/"/>
  <updated>2022-04-16T14:22:31.484Z</updated>
  <id>https://kocssds.github.io/</id>
  
  <author>
    <name>Korea Developer Support Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>로컬 HTM 혹은 HTML파일을 IE모드로 실행 방법</title>
    <link href="https://kocssds.github.io/2022/04/16/RunHtmlAsIEMode/"/>
    <id>https://kocssds.github.io/2022/04/16/RunHtmlAsIEMode/</id>
    <published>2022-04-16T14:03:37.000Z</published>
    <updated>2022-04-16T14:22:31.484Z</updated>
    
    <content type="html"><![CDATA[<p>Html 파일을 상황에 따라 Edge IE Mode 또는 Edge(또는 다른 브라우저)로 열어야 하는 경우에 대해, 연결프로그램을 바꿔서 동작하도록 설정할 수 있습니다.<br>기본적으로, html의 연결프로그램은 Edge 또는 IE만 존재하나, Edge IE Mode로 열리도록 하는 연결프로그램을 추가로 구성하실 수 있습니다.</p><p>다음의 레지스트리를 이용하여 Edge IE Mode로 열리는 연결 프로그램이 추가되는지 확인하실 수 있습니다.</p><ul><li>확장명에 대한 새 ProgID를 생성합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  [HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.html\OpenWithProgids]</span><br><span class="line">  <span class="string">&quot;MSEdgeIEModeHTML&quot;</span>=hex(0):</span><br><span class="line"> </span><br><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Classes\MSEdgeIEModeHTML]</span><br></pre></td></tr></table></figure></li><li>Internet Explorer 모드에서 여는 데 사용할 Microsoft Edge 채널로 새 ProgID를 정의합니다.<br>ProgID에는 응용 프로그램 이름 및 아이콘과 msedge.exe에 대한 전체 경로가 포함됩니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  [HKEY_CURRENT_USER\SOFTWARE\Classes\MSEdgeIEModeHTML\Application]</span><br><span class="line">  <span class="string">&quot;ApplicationCompany&quot;</span>=<span class="string">&quot;Microsoft Corporation&quot;</span></span><br><span class="line">  <span class="string">&quot;ApplicationName&quot;</span>=<span class="string">&quot;Microsoft Edge with IE Mode&quot;</span></span><br><span class="line">  <span class="string">&quot;ApplicationIcon&quot;</span>=<span class="string">&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe,0&quot;</span></span><br><span class="line">  <span class="string">&quot;AppUserModelId&quot;</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">  [HKEY_CURRENT_USER\SOFTWARE\Classes\MSEdgeIEModeHTML\DefaultIcon]</span><br><span class="line">  @=<span class="string">&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe,4&quot;</span></span><br><span class="line"> </span><br><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Classes\MSEdgeIEModeHTML\shell]</span><br><span class="line"> </span><br><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Classes\MSEdgeIEModeHTML\shell\open]</span><br></pre></td></tr></table></figure></li><li>IE 모드에서 여는 데 필요한 명령줄을 전달하도록 셸 업데이트를 구성합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Classes\MSEdgeIEModeHTML\shell\open\<span class="built_in">command</span>]</span><br><span class="line">@=<span class="string">&quot;\&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\&quot; -ie-mode-file-url -- \&quot;%1\&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>Edge 실행파일이 설치된 경로는 시스템 환경에 맞게 수정이 필요합니다.</li></ul></li></ul><p>위 내용은 <a href="https://docs.microsoft.com/ko-kr/deployedge/edge-ie-mode-add-guidance-filetype-associations#guidance-for-file-extension-association-with-internet-explorer-mode">Internet Explorer 모드와 파일 확장명 연결에 대한 지침 공식 문서</a>를 참조하여 작성되었습니다. 상세 내용은 해당 문서 참조바랍니다.</p><p><strong>적용 결과 :</strong> </p><p>html파일을 우클릭하여 연결 프로그램 목록을 살펴보면, 레지스트리로 추가한 Microsoft Edge with IE Mode 항목이 추가된것을 확인할 수 있습니다. 필요에 따라 Edge 또는 IE Mode로 연결프로그램을 선택하여 실행합니다.</p><p> <img src="/images/2022-04-16-23-14-29.png"></p><p>IE Mode로 열린 html 파일의 모습입니다.</p><p> <img src="/images/2022-04-16-23-15-03.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Html 파일을 상황에 따라 Edge IE Mode 또는 Edge(또는 다른 브라우저)로 열어야 하는 경우에 대해, 연결프로그램을 바꿔서 동작하도록 설정할 수 있습니다.&lt;br&gt;기본적으로, html의 연결프로그램은 Edge 또는 IE만 존재하나, </summary>
      
    
    
    
    
    <category term="Microsoft Edge" scheme="https://kocssds.github.io/tags/Microsoft-Edge/"/>
    
    <category term="Chromium" scheme="https://kocssds.github.io/tags/Chromium/"/>
    
    <category term="IE Mode" scheme="https://kocssds.github.io/tags/IE-Mode/"/>
    
  </entry>
  
  <entry>
    <title>Edge 브라우저에서 주소창에 “안전하지 않음” 메시지가 나옵니다</title>
    <link href="https://kocssds.github.io/2022/04/15/EdgeNotSecure/"/>
    <id>https://kocssds.github.io/2022/04/15/EdgeNotSecure/</id>
    <published>2022-04-15T00:37:58.000Z</published>
    <updated>2022-04-15T01:05:23.140Z</updated>
    
    <content type="html"><![CDATA[<p>Microsoft (Chrominum) Edge 브라우저를 사용하는 중에 간혹 주소입력창에 “안전하지 않음” 이라는 메시지를 확인할 수 있습니다.<br>Edge 브라우저에서는 <em><strong>기본적으로 HTTP를 사용하거나 인증서가 완전하지 않은 경우</strong></em>에 “<em><strong>안전하지 않음</strong></em>” 이라는 메시지가 주소창에 표시될 수 있습니다.<br>이에 대해서 HTTP를 주로 사용하여 관리하는 사내 사이트에 접근할 때, 해당 메시지를 숨기고 싶은 경우가 있는 데, 이 경우에는 그룹정책을 통해서 해당 메시지를 감출 수 있습니다. </p><p>기본적으로 다음의 그룹정책을 통해 적용이 가능합니다. 그룹 정책 또는 레지스트리에 원하는 도메인을 추가하여 안전하지 않음 메시지를 회피할 수 있습니다.</p><p><strong>[그룹 정책을 이용한 방법]</strong></p><ol><li>   아래 경로의 그룹정책 편집을 선택합니다. </li></ol><blockquote><p>그룹 정책 이름 : <em><strong>안전하지 않은 원본에 대한 보안 제한이 적용되는 위치 제어</strong></em></p></blockquote><blockquote><p>그룹 정책 경로 : 관리 템플릿 / Microsoft Edge </p></blockquote><p>** 사전 요구 사항 : MSEdge.admx 관리 템플릿이 적용되어있어야 합니다. </p><ol start="2"><li><p>사용을 선택후, 표시 버튼을 클릭하여 등록하려는 주소를 지정합니다.<br><img src="/images/2022-04-15-09-54-32.png"></p></li><li><p>여러 사이트를 등록할 수 있습니다. url 입력시, 와일드카드를 인식합니다.<br><img src="/images/2022-04-15-09-53-54.png"><br>상세 url 작성 패턴은 해당 링크를 따릅니다. <a href="https://docs.microsoft.com/ko-kr/DeployEdge/edge-learnmmore-url-list-filter%20format">Microsoft Edge URL 정책용 필터 형식 | Microsoft Docs</a></p></li></ol><p>•     Edge://policy에서 “정책 새로 고침” 하여 내용을 반영합니다.<br> <img src="/images/2022-04-15-09-56-34.png"></p><p>•    앞서서 언급한 그룹정책은 아래의 레지스트리와 관련이 있으므로 참고하실 수 있습니다. </p><p> <em><strong>비보안 원본에 대해 보안 제한이 적용되는 위치 제어</strong></em> : <a href="https://docs.microsoft.com/ko-kr/DeployEdge/microsoft-edge-policies#windows-information-and-settings">OverrideSecurityRestrictionsOnInsecureOrigin</a></p><p>•    추가적으로 정책 적용후에도 여전히 일부 사이트에선 안전하지 않음 문구가 나타날 수 있습니다. 해당 사이트들은 https 사이트에서 http컨텐츠가 혼합된 mixed content 사이트로, 해당 페이지에서 http 리소스를 https로 전환 후에 안전하지 않음 표시가 사라짐을 확인할 수 있습니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Microsoft (Chrominum) Edge 브라우저를 사용하는 중에 간혹 주소입력창에 “안전하지 않음” 이라는 메시지를 확인할 수 있습니다.&lt;br&gt;Edge 브라우저에서는 &lt;em&gt;&lt;strong&gt;기본적으로 HTTP를 사용하거나 인증서가 완전하지</summary>
      
    
    
    
    
    <category term="Microsoft Edge" scheme="https://kocssds.github.io/tags/Microsoft-Edge/"/>
    
    <category term="Chromium" scheme="https://kocssds.github.io/tags/Chromium/"/>
    
    <category term="Not Secure" scheme="https://kocssds.github.io/tags/Not-Secure/"/>
    
  </entry>
  
  <entry>
    <title>Must Not Run with Sudo</title>
    <link href="https://kocssds.github.io/2022/03/25/MustNotRunwithSudo/"/>
    <id>https://kocssds.github.io/2022/03/25/MustNotRunwithSudo/</id>
    <published>2022-03-25T01:20:51.000Z</published>
    <updated>2022-03-25T01:51:51.244Z</updated>
    
    <content type="html"><![CDATA[<p>Azure Pipeline을 통해서 배포하는 방법 중에 대표적인 방법이 Deployment Groups(DG)를 이용하는 방법입니다. 애플리케이션의 배포 대상에 해당하는 준비된 머신이 존재한다면, 해당 머신에 VSTS Agent를 설치하여 Azure DevOps에 해당 머신을 DG에 등록하고 사용하게 됩니다. 구성하는 방법에 대해서는 다음의 문서에서 절차적으로 설명하고 있습니다. </p><p><a href="https://docs.microsoft.com/ko-kr/azure/devops/pipelines/release/deployment-groups/?view=azure-devops">배포그룹 프로비저닝</a></p><p>상위의 절차를 살펴보면, 가장 중요한 작업이 Azure DevOps 사이트에서 제공하는 Script를 대상 서버에서 실행하여 VSTS Agent를 설치하는 과정일 것입니다. 간혹 Azure 에서 제공하는 Linux 머신(Cent OS 7)을 대상으로 상위 문서의 절차 3에 해당하는 방법을 이용하여 제공된 script를 대상 머신에서 실행할 경우에 Must not run with sudo 오류가 발생하는 경우가 있습니다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./config.sh</span><br><span class="line">Must not run with sudo</span><br><span class="line">sudo: ./svc.sh: <span class="built_in">command</span> not found</span><br><span class="line">sudo: ./svc.sh: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p>상위와 같은 오류가 보고된다면 script 를 실행할 때 root 권한을 갖은 쉘에서 해당 스크립트를 실행한 것인지 확인하십시오. 만일, 그렇다면 기존에 root 계정으로 설치된 폴더(azagent)를 모두 삭제하고, root 권한을 빠져나온 후에 사용자 계정으로 해당 script를 다시 실행하여 해당 오류를 피할 수 있습니다.</p><p>상위의 방법으로 해당 문제를 피할 경우에도 간혹 .NET Core 3.1로 인하여 문제가 발생할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./license.html</span><br><span class="line">./run.sh</span><br><span class="line">./run-docker.sh</span><br><span class="line">./config.sh</span><br><span class="line">libicu<span class="string">&#x27;s dependencies missing for .NET Core 3.1</span></span><br><span class="line"><span class="string">Execute ./bin/installdependencies.sh to install any missing dependencies.</span></span><br><span class="line"><span class="string">sudo: ./svc.sh: command not found</span></span><br><span class="line"><span class="string">sudo: ./svc.sh: command not found</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/v2-linux?view=azure-devops">Deploy an Azure Pipelines agent on Linux - Azure Pipelines | Microsoft Docs</a> 문서의 note를 살펴보면, </p><blockquote><p>Mariner OS distribution currently has partial support from the Azure DevOps Agent. We are providing a mechanism for detection of this OS distribution in installdependencies.sh script, but due to lack of support from the .Net Core side, we couldn’t guarantee full operability of all agent functions when running on this OS distribution.” </p></blockquote><p>언급을 확인할 수 있습니다. </p><p>이를 해결하기 위해 먼저 agent directory에서 “<strong>sudo ./bin/installdependencies.sh</strong>”을 실행하여 종속적인 모듈부분을 모두 해결한 이후에 한 번 더 registration script를 반복 실행하면 정상적으로 설치를 할 수 있습니다. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Azure Pipeline을 통해서 배포하는 방법 중에 대표적인 방법이 Deployment Groups(DG)를 이용하는 방법입니다. 애플리케이션의 배포 대상에 해당하는 준비된 머신이 존재한다면, 해당 머신에 VSTS Agent를 설치하여 Azu</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Deployment Groups" scheme="https://kocssds.github.io/tags/Deployment-Groups/"/>
    
    <category term="Azure Pipeline" scheme="https://kocssds.github.io/tags/Azure-Pipeline/"/>
    
    <category term="VSTS Agent" scheme="https://kocssds.github.io/tags/VSTS-Agent/"/>
    
  </entry>
  
  <entry>
    <title>Linux 환경에서 Azure Pipeline Agent 실행시에 [SSL Policy Errors] 발생 이슈</title>
    <link href="https://kocssds.github.io/2022/02/06/SSLPolicyErrorInPipeAgent/"/>
    <id>https://kocssds.github.io/2022/02/06/SSLPolicyErrorInPipeAgent/</id>
    <published>2022-02-06T11:03:51.000Z</published>
    <updated>2022-02-06T11:33:56.953Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 머신에서 Azure Pipeline Agent를 수행하는 경우에 “The SSL connection could not be established, see inner exception” 와 같은 오류 메시지와 함께 정상 수행되지 않는 경우가 있습니다. 보고된 메시지 자체는 매우 일반적인 메시지이므로, 좀 더 자세한 오류 정보가 필요합니다.<br>일반적으로 Azure Pipeline Agent의 경우는 Agent가 설치된 디렉토리 밑에 _diag 라는 폴더가 존재합니다. 해당 폴더에는 Agent_YYYYMMDD-0XXXXX-utc.log 같은 형태의 로그가 저장되어 있습니다. 그러므로, 문제가 발생한 시점을 확인하면 보다 자세한 오류를 확인할 수 있는 데, 해당 에러는 아래의 오류에 의해서 발생한 메시지였습니다.</p><blockquote><p>[SSL Policy Errors]<br><code>RemoteCertificateChainErrors: ChainStatus has returned a non empty array</code><br>…</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">YYYY-MM-DD TT:MM:SSZ ERR  VisualStudioServices</span>] GET request to https:<span class="comment">//dev.azure.com/organization/_apis/connectionData?connectOptions=X&amp;lastChangeId=XXXXXXXXX&amp;lastChangeId64=XXXXXXXXX failed. System.Net.Http.HttpRequestException: The SSL connection could not be established, see inner exception.</span></span><br><span class="line"> ---&gt; System.Security.Authentication.AuthenticationException: The remote certificate <span class="keyword">is</span> invalid according to the validation procedure.</span><br><span class="line">   at System.Net.Security.SslStream.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception)</span><br><span class="line">   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.PartialFrameCallback(AsyncProtocolRequest asyncRequest)</span><br></pre></td></tr></table></figure><p>해당 문제는 해당 Linux (CentOS)에서 수행하는 Azure Pipeline Agent가 .NET Core App임에 따라 아래의 언급된 내용과 관련이 있을 수 있습니다.</p><p><a href="https://github.com/dotnet/core/blob/main/Documentation/linux-setup.md#ssl-certificate-resolution-with-snap-installs">SSL Certificate resolution with Snap installs</a></p><p>On some distros, a few environment variables need to be set in order for .NET Core to properly find the SSL certificate. …<br>To resolve this issue</p><blockquote><p><code>export SSL_CERT_FILE=[certificate file location and name]</code><br /><br><code>export SSL_CERT_DIR=/dev/null</code></p></blockquote><p>예를 들어, CentOS에서 문제가 발생한 경우라면, 아래와 같은 환경 변수의 추가 이후에 Agent를 다시 실행한다면, 문제를 피할 수 있습니다. </p><blockquote><p><code>export SSL_CERT_FILE=/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem</code> <br /><br><code>export SSL_CERT_DIR=/dev/null</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux 머신에서 Azure Pipeline Agent를 수행하는 경우에 “The SSL connection could not be established, see inner exception” 와 같은 오류 메시지와 함께 정상 수행되지 않는 경</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Azure Pipeline Agent" scheme="https://kocssds.github.io/tags/Azure-Pipeline-Agent/"/>
    
  </entry>
  
  <entry>
    <title>Guest users are not permitted to access this organization as per organization policy</title>
    <link href="https://kocssds.github.io/2022/01/13/GuestUserAreNotPermittedToAccessOrg/"/>
    <id>https://kocssds.github.io/2022/01/13/GuestUserAreNotPermittedToAccessOrg/</id>
    <published>2022-01-13T01:08:18.000Z</published>
    <updated>2022-01-13T01:18:04.098Z</updated>
    
    <content type="html"><![CDATA[<p>Azure DevOps에 게스트 사용자를 이용해 Organization을 만들었을 때, 생성하는 것까지는 성공한 것으로 보이나 해당 Organization에 접근이 불가능합니다. (<strong>TF909091: Guest users are not permitted to access this organization as per organization policy</strong>)</p><p>TF909091 코드는 메시지 그대로 게스트 사용자가 정책에 의하여 조직에 접근할 수 없음을 의미합니다.<br>외부 사용자의 접근 허용 여부를 결정하는 “<strong>External Guest Access</strong>”라고 하는 옵션이 현재 기본 <strong>Off</strong>인 것으로 확인되는데, 보안적인 측면에서 게스트 사용자가 조직에 접근하지 못하는 상황입니다.</p><p>해당 문제를 피할 수 있는 방법은 현재 Guest인 사용자를 Member로 전환하고 브라우저 캐시를 완전히 삭제 후 로그인하실 수 있습니다.<br> <img src="/images/2022-01-13-10-10-23.png"></p><p>&lt;이미지 출처: <a href="https://docs.microsoft.com/ko-kr/azure/devops/organizations/accounts/add-external-user?view=azure-devops#prerequisites">https://docs.microsoft.com/ko-kr/azure/devops/organizations/accounts/add-external-user?view=azure-devops#prerequisites</a> &gt;</p><p>Azure AD 게스트 사용자를 Member로 전환하는 방법에 대해서는 문서 <a href="https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/faq-azure-access?view=azure-devops#q--how-can-i-convert-an-azure-ad-guest-into-a-member-">“Q: How can I convert an Azure AD guest into a member?” Access via Azure AD FAQs | Microsoft Docs</a> 를 참고하셨으면 좋겠습니다. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Azure DevOps에 게스트 사용자를 이용해 Organization을 만들었을 때, 생성하는 것까지는 성공한 것으로 보이나 해당 Organization에 접근이 불가능합니다. (&lt;strong&gt;TF909091: Guest users are no</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Azure AD" scheme="https://kocssds.github.io/tags/Azure-AD/"/>
    
  </entry>
  
  <entry>
    <title>Azure Boards 내에서 특정 이메일로의 Notification 방법</title>
    <link href="https://kocssds.github.io/2021/12/21/NotificationForAzureBoards/"/>
    <id>https://kocssds.github.io/2021/12/21/NotificationForAzureBoards/</id>
    <published>2021-12-21T00:59:18.000Z</published>
    <updated>2021-12-21T01:07:01.271Z</updated>
    
    <content type="html"><![CDATA[<p>간혹, Azure Boards를 사용하는 사용자에게 정의된 이메일 계정이 존재하지 않는 경우에도 대체할 수 있는 다른 이메일 계정이 존재한다면, 해당 이메일 계정으로 Notification이 가능합니다. 예를 들어, Azure Boards내에서 특정사용자에서 Work Item할당시 해당 사용자와 연관된 다른 이메일 계정으로 작업에 대한 알림을 보내기 위해 다음과 같이 설정할 수 있습니다. </p><p>특정 사용자의 Azure DevOps 사이트안에서 <strong>User Settings</strong> &gt; <strong>Notifications</strong>에 들어가시면, <strong>New subscription</strong>을 확인하실 수 있습니다.<br> <img src="/images/2021-12-21-10-01-24.png"></p><p>Category에 “<strong>Work</strong>”를 선택하고, 예를 들어 <strong>Template</strong>을 임의로 하나를 선택합니다.<br><img src="/images/2021-12-21-10-01-40.png"></p><p>아래의 화면에서 “<strong>Deliver to</strong>”에 “<strong>Other email</strong>”을 선택하고, “<strong>Address</strong>” 에 대체할 수 있는 이메일 계정을 선택하면 됩니다. 이후에 해당 사용자에게 Work Item이 할당이 된다면, 지정된 이메일 계정으로 메일이 전송됩니다.<br><img src="/images/2021-12-21-10-01-57.png"></p><p>관련해서는 문서 <a href="https://docs.microsoft.com/en-us/azure/devops/notifications/concepts-email-recipients?view=azure-devops">How notification email recipients are determined - Azure DevOps | Microsoft Docs</a> 문서를 참고할 수 있습니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;간혹, Azure Boards를 사용하는 사용자에게 정의된 이메일 계정이 존재하지 않는 경우에도 대체할 수 있는 다른 이메일 계정이 존재한다면, 해당 이메일 계정으로 Notification이 가능합니다. 예를 들어, Azure Boards내에서 </summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Azure Boards" scheme="https://kocssds.github.io/tags/Azure-Boards/"/>
    
    <category term="Notification" scheme="https://kocssds.github.io/tags/Notification/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps Agent를 systemd 서비스로 구동 시 No such file or directory 오류를 만날 수 있다</title>
    <link href="https://kocssds.github.io/2021/12/03/AzureDevOpsServiceAsSystemd/"/>
    <id>https://kocssds.github.io/2021/12/03/AzureDevOpsServiceAsSystemd/</id>
    <published>2021-12-03T04:57:46.000Z</published>
    <updated>2021-12-03T05:05:27.468Z</updated>
    
    <content type="html"><![CDATA[<p>Azure DevOps Pipeline Agent머신으로 Linux 머신을 사용할 때 실행되는 Agent 프로그램을 systemd 서비스로 구동 시킬 수 있습니다. 일반적인 경우에는 <a href="https://docs.microsoft.com/ko-kr/azure/devops/pipelines/agents/v2-linux?view=azure-devops#run-as-a-systemd-service">https://docs.microsoft.com/ko-kr/azure/devops/pipelines/agents/v2-linux?view=azure-devops#run-as-a-systemd-service</a> 문서 내용을 참고하여 systemd 서비스로의 설정에는 복잡한 문제가 있어 보이진 않습니다. 하지만, 흥미롭게도 아래와 같은 문제를 만날 수도 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[testadm@scselagentw1 azure-devops]$ sudo ./svc.sh status</span><br><span class="line">/etc/systemd/system/vsts.agent.testcorp.Default.scselagentw1.service</span><br><span class="line">● vsts.agent.testcorp.Default.scselagentw1.service - Azure Pipelines Agent (testcorp.Default.scselagentw1)</span><br><span class="line"></span><br><span class="line">   Loaded: loaded (/etc/systemd/system/vsts.agent.testcorp.Default.scselagentw1.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: exit-code) since Mon 2021-11-08 17:53:45 KST; 45s ago</span><br><span class="line">  Process: 1259 ExecStart=/agent/azure-devops/runsvc.sh (code=exited, status=200/CHDIR)</span><br><span class="line">Main PID: 1259 (code=exited, status=200/CHDIR)</span><br><span class="line"></span><br><span class="line">Nov 08 17:53:45 scselagentw1 systemd[1]: Started Azure Pipelines Agent (testcorp.Default.scselagentw1).</span><br><span class="line">Nov 08 17:53:45 scselagentw1 systemd[1259]: Failed at step CHDIR spawning /agent/azure-devops/runsvc.sh: No such file or directory</span><br><span class="line">Nov 08 17:53:45 scselagentw1 systemd[1]: vsts.agent.testcorp.Default.scselagentw1.service: main process exited, code=exit...0/CHDIR</span><br><span class="line">Nov 08 17:53:45 scselagentw1 systemd[1]: Unit vsts.agent.testcorp.Default.scselagentw1.service entered failed state.</span><br><span class="line">Nov 08 17:53:45 scselagentw1 systemd[1]: vsts.agent.testcorp.Default.scselagentw1.service failed.</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure><p>해당 문제가 흥미로운 이유는 오류메시지에 기인하여 관련된 서비스 파일등의 권한문제를 확인해 봤음에도 불구하고 별다른 권한 등의 문제가 존재하지 않는 다는 점입니다. 만일, 그렇다면 해당 agent가 설치된 폴더의 위치가 <a href="https://github.com/Azure/azure-storage-fuse">blobfuse</a>에 위치하는 지 확인해 보실 수 있습니다.<br>원인은 blobfuse file system이 mount되기 전에 Azure DevOps agent 서비스가 더 일찍 실행되는 경우가 발생할 수 있으며 이로 인하여 No such file or directory오류가 발생할 수 있기 때문입니다. 그러므로, 이와 같은 경우에는 agent 설치 위치를 blobfuse가 아닌 local 로 변경하여 해당 문제를 회피하는 것이 좋겠습니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Azure DevOps Pipeline Agent머신으로 Linux 머신을 사용할 때 실행되는 Agent 프로그램을 systemd 서비스로 구동 시킬 수 있습니다. 일반적인 경우에는 &lt;a href=&quot;https://docs.microsoft.com</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Linux" scheme="https://kocssds.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps와 사용자에 대한 흥미로운 몇 가지 의견들</title>
    <link href="https://kocssds.github.io/2021/11/03/ManageAzureDevOpsAndUsers/"/>
    <id>https://kocssds.github.io/2021/11/03/ManageAzureDevOpsAndUsers/</id>
    <published>2021-11-03T01:04:15.000Z</published>
    <updated>2021-11-03T01:27:18.976Z</updated>
    
    <content type="html"><![CDATA[<p>Azure DevOps 서비스에서는 사용자를 조직에 직접추가하고 관리할 수 있는 기능이 존재합니다. 이에 대해서 몇가지 흥미로운 아래와 같은 사실을 참고하실 수 있습니다.</p><ol><li><p>동일한 Email을 사용하여 Business 혹은 Personal account의 사용을 허용하더라도 사용하지 않는 것이 좋습니다.  </p><blockquote><p>We recommend using a different email or user principal name (UPN) for your personal and business accounts, rather than using the same, even though it’s allowed. This eliminates the challenge of disambiguating between your business and personal accounts when the email/UPN is the same. &lt;출처: <a href="https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/add-external-user?view=azure-devops&gt;">https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/add-external-user?view=azure-devops&gt;</a></p></blockquote></li><li><p>   Azure DevOps에 등록된 사용자에 대해서 기대하는 계정 타입으로의 변경(AAD 혹은 Personal)은 기존의 계정을 제거하고 다시 추가하는 방법을 통해서 가능합니다. Azure DevOps에서 계정 타입을 switch 할 수 있는 기능은 없습니다.</p></li><li><p>Azure DevOps Access Level을 Stakeholder에서 Basic으로 변경을 할 수 있는 권한주체 확인과 관련해서는 <strong>Project Collection Administrator</strong> 또는 <strong>Owner</strong>의 경우에 가능합니다. </p><blockquote><p>“For users tasked with managing organization or collection-level features —such as, projects, policies, processes, retention policies, agent and deployment pools, and extensions—add them to the Project Collection Administrators group.” &lt;출처: <a href="https://github.com/MicrosoftDocs/azure-devops-docs/blob/master/docs/organizations/security/set-project-collection-level-permissions.md&gt;">https://github.com/MicrosoftDocs/azure-devops-docs/blob/master/docs/organizations/security/set-project-collection-level-permissions.md&gt;</a></p></blockquote></li><li><p>   하나의 테넌트에 두개의 AAD 보안 그룹이 있고, 이 그룹이 각각 DevOps 조직을 소유하고 있습니다. 그 중 한 AAD 그룹에 사용자를 추가하면, Azure DevOps에 로그온이 되는 지에 대해서는 AAD에 사용자를 추가하더라도 Azure DevOps의 조직에 사용자를 직접 추가해야 합니다. 개념적으로 보면 Azure DevOps의 사용자는 AAD 사용자와 “매핑”이 되는 것이며, AAD에서 사용자를 추가/삭제한다고 해서 Azure DevOps에 자동으로 반영이 되지 않습니다. </p></li><li><p>   Azure DevOps 가 구독과 연계되어 생성되는 것인지에 대해서는 Azure DevOps는 파이프라인, 에이전트 풀 등에 추가 과금을 하거나 서비스 연결을 생성하기 위하여 구독을 설정하여 사용할 수 있으나 Azure DevOps가 구독을 연결해야만 생성되는 서비스는 아닙니다. 구독을 연결하지 않고도 서비스는 free tier로도 사용하실 수 있습니다. 그리고 Azure DevOps는 ‘조직’이라는 큰 단위에서 하위 팀 프로젝트들을 관리하는데, 여러 조직이 하나의 구독과 연결될 수 있습니다. 다시 말하자면, 구독과 서비스의 생성은 별개라고 할 수 있습니다. </p></li><li><p>   하나의 AAD 테넌트에서 하나의 DevOps 앱만 사용하는지, 생성시 이를 명시적으로 분할할 수 있는지에 대해서는 하나의 AAD 테넌트에서 Azure DevOps 앱은 분리가 되지 않습니다. Azure DevOps 앱을 두 개 만들어 조직에 각각 나눠지는 구조는 불가능합니다.</p></li><li><p>Azure DevOps 로그인을 할 때 사용자에 대한 특정 위치에서의 접근을 막고자 하는 목적이라면 AAD에서 제공하는 IP 기반으로 하는 조건부 액세스 정책을 고려해볼 수 있습니다.</p><blockquote><p>&lt;<a href="https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview#common-signals">https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/overview#common-signals</a><br>(Common signals &gt; IP Location information 부분 참고&gt;</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Azure DevOps 서비스에서는 사용자를 조직에 직접추가하고 관리할 수 있는 기능이 존재합니다. 이에 대해서 몇가지 흥미로운 아래와 같은 사실을 참고하실 수 있습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;동일한 Email을 사용하여 Business </summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Azure AD" scheme="https://kocssds.github.io/tags/Azure-AD/"/>
    
    <category term="MSA" scheme="https://kocssds.github.io/tags/MSA/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps에서의 Service Connection에 대해</title>
    <link href="https://kocssds.github.io/2021/10/15/MakeServiceConnectionForDevOps/"/>
    <id>https://kocssds.github.io/2021/10/15/MakeServiceConnectionForDevOps/</id>
    <published>2021-10-15T06:24:54.000Z</published>
    <updated>2021-10-15T08:45:37.501Z</updated>
    
    <content type="html"><![CDATA[<p>Azure DevOps Pipeline에서 Azure Resource를 사용하여 처리하기 위해서는 Azure Resource에 대한 접근 권한이 필요합니다. 실 예로 Azure Pipeline의 구성을 위해 임의의 Task을 추가하여 실행할 경우에 해당 Task를 실행 시 Azure Resource의 접근을 위해 Azure Subscription 정보를 입력하는 경우가 있는 데, 이에 해당하는 적절한 Service Connection을 생성하여 입력 처리하는 것이 일반적입니다. 이때 필요한 Service Connection은 다음과 같은 과정을 거쳐서 생성할 수 있습니다. </p><h3 id="Azure-DevOps-Service-Connection-추가"><a href="#Azure-DevOps-Service-Connection-추가" class="headerlink" title="Azure DevOps Service Connection 추가"></a><strong>Azure DevOps Service Connection 추가</strong></h3><ol><li>   Azure DevOps 포털에 로그인합니다. </li><li>   해당 Project의 Project settings에 들어갑니다.</li><li>   Service Connections에서 새로운 Service Connection을 생성합니다. </li><li>   New Service Connection에서 Azure Resource Manager를 선택합니다. </li><li>   Authentication Metod는 Service principal (automatic)을 선택한 후 다음을 누릅니다.</li><li>   Scope level은 Subscription으로 선택하고 하단의 Security는 “Grant access permission to all pipelines” 체크합니다.</li><li>   Subscription, Resource Group(기존에 생성한 Resource Group을 선택) 그리고, Service Connection 이름(예를 들어, ”AppConnection”)을 입력하고 저장합니다.</li></ol><p>정상적으로 Service Connection이 생성되면, AppConnection이라는 이름의 Service Connection이 생성이 되며, 이를 클릭하면 아래와 같은 메뉴를 확인할 수 있습니다. </p><ul><li>Manage Service Connection roles</li><li>Manage Service Principal</li></ul><p><img src="/images/2021-10-15-15-31-26.png"></p><h3 id="Manage-Service-Principal"><a href="#Manage-Service-Principal" class="headerlink" title="Manage Service Principal"></a><strong>Manage Service Principal</strong></h3><p>“Manage Service Principal”을 클릭하면, Azure 포털에 존재하는 Service Principal을 확인할 수 있는 데, 일반적으로 “조직이름-프로젝트이름-UUID” 형태의 이름을 가지고 있습니다. 해당 Service Principal의 좌측 메뉴에 Certificates $ secret을 확인해 보면, 기본적으로 Client secrets가 존재하고, 이에 대한 만료일이 지정되어 있기 때문에 이에 대해서는 반드시 확인하여 만료이후에 Azure Pipeline 처리에 문제가 되지 않도록 관리해야 합니다.<br>간혹 갱신 이후에 “Failed to obtain the Json Web Token(JWT) using service principal client ID. Exception message: AADSTS7000215: Invalid client secret is provided.” 이와 같은 오류가 발생할 수 있는 데, 이 경우에는 아래와 같은 단계를 통해서 문제를 피할 수 있습니다.</p><ol><li>   Service Connections에서 문제가 되는 Service Connection을 선택하고 Edit를 클릭합니다. </li><li>   Description(optional)을 수정하고 저장합니다. (Verify는 하지 마십시오.)</li><li>   Service Connection Edit 화면을 빠져나간 후에 해당 페이지를 refresh합니다. </li><li>   다시 Edit 화면으로 들어가서 Verify를 선택합니다. </li><li>   다시 저장 버튼을 클릭하여 저장합니다. </li></ol><h3 id="Manage-service-connection-roles"><a href="#Manage-service-connection-roles" class="headerlink" title="Manage service connection roles"></a><strong>Manage service connection roles</strong></h3><p>또한, “Manage service connection roles”를 클릭하면, Azure Portal로 이동하면서 해당 Service Principal 이 속한 Subscription 정보의 Access Control(IAM)를 확인할 수 있습니다. IAM의 role assignments 메뉴를 확인하면, Azure DevOps에서 등록된 Service Principal 이 “App” type의 <strong>Contributor Role</strong>로써 등록이 된 것으로 확인할 수 있습니다. </p><p>만일, 추가적인 권한이 필요하다면, </p><ol><li>   Add Role Assignment 메뉴로 들어가서 </li><li>   “Role”에 필요한 권한을 선택하고, </li><li>   “Assign access to”에 “user, group or service principal”을 선택, 그리고, “select”에 앞서서 생성한 Service Principal을 검색하여 선택하면, </li></ol><p>원하는 Role에 Azure DevOps에서 생성한 Service Principal을 추가할 수 있습니다. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Azure DevOps Pipeline에서 Azure Resource를 사용하여 처리하기 위해서는 Azure Resource에 대한 접근 권한이 필요합니다. 실 예로 Azure Pipeline의 구성을 위해 임의의 Task을 추가하여 실행할 경우</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Service Connection" scheme="https://kocssds.github.io/tags/Service-Connection/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps Service가 제공하는 Deployment Groups를 이용하여 Linux 머신에 Spring-Boot App을 배포하기</title>
    <link href="https://kocssds.github.io/2021/09/27/DeployAppUsingDeployGroups/"/>
    <id>https://kocssds.github.io/2021/09/27/DeployAppUsingDeployGroups/</id>
    <published>2021-09-27T00:47:05.000Z</published>
    <updated>2021-09-27T01:04:51.925Z</updated>
    
    <content type="html"><![CDATA[<p>Azure DevOps Service는 CI/CD 파이프라인 기능을 이용해 다양한 방법을 통해서 앱을 원하는 배포 머신에 배포할 수 있습니다. 그 중에서 Deployment Groups에 배포 머신을 등록하고 이를 이용하여 앱을 배포하는 방법에 대해서는 다음과 같은 절차를 통해서 접근해 보실 수 있습니다. </p><h3 id="Azure-DevOps-Repo의-구성"><a href="#Azure-DevOps-Repo의-구성" class="headerlink" title="Azure DevOps Repo의 구성"></a><strong>Azure DevOps Repo의 구성</strong></h3><ol><li>   Azure DevOps 포털에 로그온 합니다.</li><li>   New Project를 선택하여 새로운 Project를 생성합니다. </li><li>   생성된 Project로 들어가서 좌측의 Repos메뉴를 선택합니다. </li><li>   이후 Import a Repository 부분에서 사용하고자 하는 Spring Boot 예제를 import 하여 구성합니다. (예, <a href="https://github.com/spring-guides/gs-spring-boot.git">https://github.com/spring-guides/gs-spring-boot.git</a>  )</li></ol><h3 id="Azure-Build-Pipeline을-구성"><a href="#Azure-Build-Pipeline을-구성" class="headerlink" title="Azure Build Pipeline을 구성"></a><strong>Azure Build Pipeline을 구성</strong></h3><ol><li>   Pipelines에서 New Pipeline을 선택합니다. </li><li>   Azure Repos Git을 선택하여 이전 단계에서 구성한 Repo를 선택합니다. </li><li>   Configure your pipeline 단계에서는 Repo에 구성된 소스를 컴파일하기 위해 Maven (build your java project and run tests with Apache Maven)을 선택합니다. </li><li>   프로젝트 내에 azure-pipelines.yml 파일이 자동 생성되고, 아래와 같이 내용을 추가합니다.</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pool:</span></span><br><span class="line">  <span class="attr">vmImage:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">Maven@3</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">mavenPomFile:</span> <span class="string">&#x27;complete/pom.xml&#x27;</span></span><br><span class="line">    <span class="attr">mavenOptions:</span> <span class="string">&#x27;-Xmx3072m&#x27;</span></span><br><span class="line">    <span class="attr">javaHomeOption:</span> <span class="string">&#x27;JDKVersion&#x27;</span></span><br><span class="line">    <span class="attr">jdkVersionOption:</span> <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">    <span class="attr">jdkArchitectureOption:</span> <span class="string">&#x27;x64&#x27;</span></span><br><span class="line">    <span class="attr">publishJUnitResults:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testResultsFiles:</span> <span class="string">&#x27;**/surefire-reports/TEST-*.xml&#x27;</span></span><br><span class="line">    <span class="attr">goals:</span> <span class="string">&#x27;package&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">CopyFiles@2</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&#x27;Copy Files to: $(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">SourceFolder:</span> <span class="string">&#x27;$(system.defaultworkingdirectory)&#x27;</span></span><br><span class="line">    <span class="attr">Contents:</span> <span class="string">&#x27;**/*.?(jar|sh)&#x27;</span></span><br><span class="line">    <span class="attr">TargetFolder:</span> <span class="string">&#x27;$(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">    <span class="attr">flattenFolders:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">condition:</span> <span class="string">succeededOrFailed()</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">PublishBuildArtifacts@1</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">PathtoPublish:</span> <span class="string">&#x27;$(Build.ArtifactStagingDirectory)&#x27;</span></span><br><span class="line">    <span class="attr">ArtifactName:</span> <span class="string">&#x27;drop&#x27;</span></span><br><span class="line">    <span class="attr">publishLocation:</span> <span class="string">&#x27;Container&#x27;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>   빌드가 완료되면, Artifacts가 생성됩니다. 해당 Artifacts는 Azure Release Pipeline에서 download 받아서 처리될 예정입니다.</li></ol><h3 id="Deployment-Groups의-생성"><a href="#Deployment-Groups의-생성" class="headerlink" title="Deployment Groups의 생성"></a><strong>Deployment Groups의 생성</strong></h3><ol><li>   Azure Pipelines의 메뉴 중에 Deployment Groups를 선택하고, “New”을 클릭하여 생성합니다. </li><li>   “Deployment group name”에 임의의 이름 (예를 들면, ‘testdg’)을 입력하여 생성합니다. </li></ol><h3 id="Personal-Access-Token의-생성"><a href="#Personal-Access-Token의-생성" class="headerlink" title="Personal Access Token의 생성"></a><strong>Personal Access Token의 생성</strong></h3><ol><li>   Azure DevOps Portal에 로그온 후에 우측 상단에 User Settings메뉴가 존재하며, 이들 중 Personal Access Token 메뉴로 들어갑니다.</li><li>   New Token을 선택합니다. </li><li>   Name 과 Expiration Date를 원하는 내용으로 입력합니다.</li><li>   Scopes는 Custom defined를 선택하고, Show All Scopes를 클릭하여 확장합니다. </li><li>   리스트된 Scope 중에 Deployment Groups에 Read &amp; Manage 를 선택하여 생성합니다.</li><li>   이후 Personal Access Token을 Copy 하여 기억합니다. </li></ol><h3 id="Deployment-Groups에-포함될-Linux-VM의-생성"><a href="#Deployment-Groups에-포함될-Linux-VM의-생성" class="headerlink" title="Deployment Groups에 포함될 Linux VM의 생성"></a><strong>Deployment Groups에 포함될 Linux VM의 생성</strong></h3><ol><li>   Azure Portal에 로그온 합니다. </li><li>   Create a resource 를 통해서 Virtual Machine을 생성합니다. </li><li>   적절한 Subscription을 입력합니다. </li><li>   Resource Group에 Create New를 통해서 새롭게 생성합니다. </li><li>   Virtual machine name을 입력합니다. </li><li>   Region을 선택합니다. </li><li>   Image 를 선택합니다. (예를 들어, Ubuntu Server 18.04를 선택할 수 있습니다.)</li><li>   Size 를 선택합니다. (예를 들어, Standard D2s_V3 를 선택할 수 있습니다.)</li><li>   테스트 및 확인을 위해서 SSH (22)를 허용할 수 있습니다. </li><li>   Review + Create 를 통해서 생성합니다. </li></ol><h3 id="TeamServicesAgentLinux의-설치"><a href="#TeamServicesAgentLinux의-설치" class="headerlink" title="TeamServicesAgentLinux의 설치"></a><strong>TeamServicesAgentLinux의 설치</strong></h3><ol start="7"><li>   Azure Portal에서 앞서서 생성한 VM 리소스를 선택합니다. </li><li>   Settings에 Extensions를 선택합니다. </li><li>   +Add를 통해 “Azure Pipeline Agent For Linux”를 선택합니다. </li><li>   “Configure Azure Pipelines Agent For Linux Extension” 화면을 통해서 구성합니다. </li><li>   Azure DevOps Organization Url 에 기존에 생성한 Azure DevOps의 Project가 존재하는 조직을 포함하여 입력합니다. (예를 들어, <a href="https://dev.azure.com/organizationName&quot;">https://dev.azure.com/organizationName&quot;</a>)</li><li>   Team Project에 앞서서 구성한 Team Project의 이름을 입력합니다. </li><li>   Deployment Group에 앞서서 구성한 Deployment group name을 입력합니다. 이것은 앞서서 ‘Deployment Groups의 생성’ 단계에서 입력한 이름입니다. </li><li>   Personal Access Token에는 앞서서 ‘Personal Access Token의 생성’ 단계에서 복사한 값을 입력합니다.</li><li>   Review + Create를 통해 설치합니다. </li><li>   정상적으로 설치가 완료되면, Azure DevOps의 Deployment Groups에 생성한 Deployment Group (예를 들어, ‘Testdg’)을 선택하고, Targets를 확인하면, Healthy 상태의 VM이 등록된 것을 확인할 수 있습니다.</li></ol><h3 id="Release-Pipeline의-구성-및-실행"><a href="#Release-Pipeline의-구성-및-실행" class="headerlink" title="Release Pipeline의 구성 및 실행"></a><strong>Release Pipeline의 구성 및 실행</strong></h3><ol><li>   Azure DevOps 포털에서 Releases를 선택하고, 새로운 Release를 생성합니다. </li><li>   Add an Artifact를 통해서 Build Pipeline에서 설정된 Project와 Source를 선택한 후에 Add 합니다.</li><li>   Add a stage에서 Empty Job을 선택합니다.</li><li>   View Stage Task를 클릭합니다. </li><li>   새로운 Release Pipeline의 Tasks에 존재하는 Agent Job을 선택하고, 우측의 remove 버튼을 클릭하여 제거합니다. </li><li>   Add phase options를 클릭하여, add a deployment group job을 선택합니다. </li><li>   Deployment group job 에서 임의의 Name을 입력하고, Deployment targets의 Deployment group은 앞서서 생성한 Deployment Group을 선택합니다. (예를 들어, ‘testdg’)</li><li>   Add a task to Deployment Group Job (+ 메뉴)을 통해 Task를 추가합니다. Task는 ‘Bash’를 검색하여 추가합니다. </li><li>   Bash task 안에서 Type을 inline으로 선택하고 다음의 script 를 입력합니다.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /lib/artifacts/</span><br><span class="line">sudo cp $(System.DefaultWorkingDirectory)/_Test/drop/spring-boot-complete-0.0.1-SNAPSHOT.jar/lib/artifacts/</span><br><span class="line">sudo java -jar /lib/artifacts/spring-boot-complete-0.0.1-SNAPSHOT.jar &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li><li>   저장하고, release 를 생성한 후에 실행합니다. </li></ol><h3 id="테스트-및-확인-Linux-VM의-추가-Port-오픈"><a href="#테스트-및-확인-Linux-VM의-추가-Port-오픈" class="headerlink" title="테스트 및 확인 (Linux VM의 추가 Port 오픈)"></a><strong>테스트 및 확인 (Linux VM의 추가 Port 오픈)</strong></h3><ol><li>   Azure 포털에서 이전 단계에서 생성한 VM 환경으로 들어갑니다.</li><li>   Settings의 Networking메뉴를 선택하고, 이후 Add Inbound Port Rule을 선택합니다.</li><li>   Source Port range는 “*”, Destination Port는 “8080”, Source 와 Destination을 둘 다 Any로 선택하고, TCP에 대해서 “Allow”로써 추가합니다.</li><li>   이후 TCP 8080 포트가 오픈 됩니다.</li><li>   해당 VM의 public IP:8080 을 통해 Spring Boot App의 실행을 확인합니다.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Azure DevOps Service는 CI/CD 파이프라인 기능을 이용해 다양한 방법을 통해서 앱을 원하는 배포 머신에 배포할 수 있습니다. 그 중에서 Deployment Groups에 배포 머신을 등록하고 이를 이용하여 앱을 배포하는 방법에 </summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Linux" scheme="https://kocssds.github.io/tags/Linux/"/>
    
    <category term="QuickStart" scheme="https://kocssds.github.io/tags/QuickStart/"/>
    
    <category term="Deployment Groups" scheme="https://kocssds.github.io/tags/Deployment-Groups/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps Pipeline에서 Azure Image Builder를 이용하여 Spring Boot App을 Azure Virtual Machine Scale Set(VMSS)에 배포하기</title>
    <link href="https://kocssds.github.io/2021/08/25/DeployApptoVMSSusingImageBuilder/"/>
    <id>https://kocssds.github.io/2021/08/25/DeployApptoVMSSusingImageBuilder/</id>
    <published>2021-08-25T10:32:23.000Z</published>
    <updated>2021-08-25T11:19:12.328Z</updated>
    
    <content type="html"><![CDATA[<p>아래의 절차는 Azure DevOps에서 Azure Image Builder를 사용하는 과정을 참고하는 예제이며, 실제 업무상에 적용을 위해서는 많은 부분의 고려가 필요함을 미리 언급합니다. </p><p>Azure DevOps에서 ‘Build immutable image’ Task를 이용하면, 원하는 머신 이미지를 만들 수 있습니다. 이를 이용하여 몇몇 프로그램이 수행가능한 환경이 설치된 이미지를 생성할 수 있으며, 해당 이미지는 예를 들어 Azure VM Scale Set과 같은 환경의 인스턴스 생성에 이용할 수 있습니다. </p><p>먼저, java 실행 환경(Spring Boot 앱)이 포함된 머신 이미지를 생성하여, Azure 리소스 그룹에 포함시키는 과정은 아래와 같습니다. </p><h3 id="Azure-DevOps-Repo의-구성"><a href="#Azure-DevOps-Repo의-구성" class="headerlink" title="Azure DevOps Repo의 구성"></a><strong>Azure DevOps Repo의 구성</strong></h3><ol><li>   Azure DevOps 포털에 로그온 합니다.</li><li>   New Project를 선택하여 새로운 Project를 생성합니다. </li><li>   생성된 Project로 들어가서 좌측의 Repos메뉴를 선택합니다. </li><li>   이후 Import a Repository 부분에서 사용하고자 하는 Spring Boot 예제를 import 하여 구성합니다. (예, <a href="https://github.com/spring-guides/gs-spring-boot.git">https://github.com/spring-guides/gs-spring-boot.git</a>  )</li></ol><h3 id="Azure-DevOps-Service-Connection-추가"><a href="#Azure-DevOps-Service-Connection-추가" class="headerlink" title="Azure DevOps Service Connection 추가"></a><strong>Azure DevOps Service Connection 추가</strong></h3><ol><li>   이전 단계에서 생성된 Project의 Project settings에 들어갑니다.</li><li>   Service Connections에서 새로운 Service Connection을 생성합니다. </li><li>   New Service Connection에서 Azure Resource Manager를 선택합니다. </li><li>   Authentication Metod는 Service principal (automatic)을 선택한 후 다음을 누릅니다.</li><li>   Scope level은 Subscription으로 선택하고 Subscription, Resource Group(기존에 생성한 Resource Group을 선택) 그리고, Service Connection 이름을 입력하고 저장합니다.</li></ol><h3 id="Storage-Account의-생성"><a href="#Storage-Account의-생성" class="headerlink" title="Storage Account의 생성"></a><strong>Storage Account의 생성</strong></h3><ol><li>   Azure 포털에 로그온 합니다. </li><li>   좌측 메뉴에서 Create Resource를 선택합니다.</li><li>   찾기에서 Storage Account찾아 선택합니다. </li><li>   생성 시, 새로운 resource group을 만들고, 임의의 Storage Account의 이름을 입력한 후, 적당한 Region을 선택하여 생성합니다. </li></ol><h3 id="Shell-Script-파일의-추가"><a href="#Shell-Script-파일의-추가" class="headerlink" title="Shell Script 파일의 추가"></a><strong>Shell Script 파일의 추가</strong></h3><ol><li>   Azure DevOps 포털에 로그온 합니다. </li><li>   이전 단계에서 생성한 Project 내의 Repos의 Files로 이동합니다. </li><li>   기존의 소스 폴더에 deploy.sh라는 새로운 파일을 생성합니다.</li><li>   Deploy.sh 파일의 구성은 아래와 같습니다. <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">sudo apt-get update -y</span><br><span class="line">sudo apt-get install -y default-jre</span><br><span class="line">sudo mkdir /lib/artifacts/</span><br><span class="line">sudo cp /deployTemp/drop/*.jar /lib/artifacts/</span><br></pre></td></tr></table></figure></li></ol><ul><li>참고로.jar는 Build Pipeline을 통해서 생성될 바이너리입니다. </li><li>/deployTemp/drop/ 폴더의 위치는 Release Pipeline의 Build Immutable Image Task수행시 Artifacts가 이동될 위치입니다.</li></ul><h3 id="Azure-Build-Pipeline을-구성"><a href="#Azure-Build-Pipeline을-구성" class="headerlink" title="Azure Build Pipeline을 구성"></a><strong>Azure Build Pipeline을 구성</strong></h3><ol><li>   Pipelines에서 New Pipeline을 선택합니다. </li><li>   Azure Repos Git을 선택하여 이전 단계에서 구성한 Repo를 선택합니다. </li><li>   Configure your pipeline 단계에서는 Repo에 구성된 소스를 컴파일하기 위해 Maven (build your java project and run tests with Apache Maven)을 선택합니다. </li><li>   프로젝트 내에 azure-pipelines.yml 파일이 자동 생성되고, 아래와 같이 내용을 추가합니다.<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">trigger:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pool:</span></span><br><span class="line">  <span class="attr">vmImage:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">Maven@3</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">mavenPomFile:</span> <span class="string">&#x27;complete/pom.xml&#x27;</span></span><br><span class="line">    <span class="attr">mavenOptions:</span> <span class="string">&#x27;-Xmx3072m&#x27;</span></span><br><span class="line">    <span class="attr">javaHomeOption:</span> <span class="string">&#x27;JDKVersion&#x27;</span></span><br><span class="line">    <span class="attr">jdkVersionOption:</span> <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">    <span class="attr">jdkArchitectureOption:</span> <span class="string">&#x27;x64&#x27;</span></span><br><span class="line">    <span class="attr">publishJUnitResults:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testResultsFiles:</span> <span class="string">&#x27;**/surefire-reports/TEST-*.xml&#x27;</span></span><br><span class="line">    <span class="attr">goals:</span> <span class="string">&#x27;package&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">CopyFiles@2</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&#x27;Copy Files to: $(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">SourceFolder:</span> <span class="string">&#x27;$(system.defaultworkingdirectory)&#x27;</span></span><br><span class="line">    <span class="attr">Contents:</span> <span class="string">&#x27;**/*.?(jar|sh)&#x27;</span></span><br><span class="line">    <span class="attr">TargetFolder:</span> <span class="string">&#x27;$(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">    <span class="attr">flattenFolders:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">condition:</span> <span class="string">succeededOrFailed()</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">PublishBuildArtifacts@1</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">PathtoPublish:</span> <span class="string">&#x27;$(Build.ArtifactStagingDirectory)&#x27;</span></span><br><span class="line">    <span class="attr">ArtifactName:</span> <span class="string">&#x27;drop&#x27;</span></span><br><span class="line">    <span class="attr">publishLocation:</span> <span class="string">&#x27;Container&#x27;</span></span><br></pre></td></tr></table></figure></li><li>   빌드가 완료되면, Artifacts가 생성됩니다. 해당 Artifacts는 Azure Release Pipeline에서 download 받아서 처리될 예정입니다. </li></ol><h3 id="Azure-DevOps의-Release-Pipeline구성"><a href="#Azure-DevOps의-Release-Pipeline구성" class="headerlink" title="Azure DevOps의 Release Pipeline구성"></a><strong>Azure DevOps의 Release Pipeline구성</strong></h3><ol><li>   Azure DevOps 포털에 로그온 합니다.</li><li>   해당 Project로 들어가서 좌측의 Release 메뉴를 선택합니다. 이후 New Pipeline을 생성합니다. </li><li>   Empty Job을 선택합니다. </li><li>   Agent Job에서 Agent Specification을 ubuntu-18.04 로 선택합니다.</li><li>   Agent Job에 Build Immutable Image task를 추가합니다. </li></ol><ul><li>   적당한 Display Name을 입력합니다.</li><li>   Packer template 은 “Auto generated”로 선택합니다.</li><li>Azure subscription을 선택합니다. </li><li>Managed VM Disk image의 체크 박스를 체크하고, Name을 입력합니다. (해당 이름으로 Azure 리소스 그룹에 이미지가 생성됩니다.)</li><li>   Storage location에 적절한 region을 지정합니다.</li><li>   Storage account에 앞서서 생성한 storage account를 선택합니다.</li><li>   Resource Group에는 Storage account와 동일한 Resource group을 선택합니다.</li><li>   Base image source는 “Gallery”로 선택합니다. </li><li>   Base image는 “ubuntu 18.04-LTS”를 선택합니다. </li><li>   Deployment Package는 일반적으로 Artifacts가 생성된 위치를 지정합니다. (일반적으로 $(System.DefaultWorkingDirectory)에 대한 상대적인 위치인데, _&lt;project 이름&gt;/drop이라는 형태를 갖습니다.)</li><li>   Deployment script는 앞서서 생성한 script 파일을 입력합니다. (Build pipeline에서 .sh파일도 artifacts에 포함했으므로 해당 파일 이름을 입력합니다.)</li></ul><ol start="6"><li>   설정을 마치면, YAML 파일로는 아래와 같이 구성됩니다. <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">PackerBuild@1</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&#x27;Build immutable image&#x27;</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">ConnectedServiceName:</span> <span class="string">‘&lt;service</span> <span class="string">connection&gt;&#x27;</span></span><br><span class="line">    <span class="attr">managedImageName:</span> <span class="string">myvmssimage2</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">koreasouth</span></span><br><span class="line">    <span class="attr">storageAccountName:</span> <span class="string">myvmssstorage</span></span><br><span class="line">    <span class="attr">azureResourceGroup:</span> <span class="string">&#x27;vmss_rg&#x27;</span></span><br><span class="line">    <span class="attr">baseImage:</span> <span class="string">&#x27;Canonical:UbuntuServer:18.04-LTS:linux&#x27;</span></span><br><span class="line">    <span class="attr">packagePath:</span> <span class="string">&#x27;_vmsstest/drop&#x27;</span></span><br><span class="line">    <span class="attr">deployScriptPath:</span> <span class="string">deploy.sh</span></span><br></pre></td></tr></table></figure></li><li>   Build Pipepline과 Release Pipeline이 정상적으로 run 된다면, ‘vmss_rg’ 라는 Azure 리소스 그룹내에 myvmssstorage 라는 storage account 와 myvmssimage2 라는 이름이 image가 생성된 것으로 확인할 수 있습니다. </li><li>   해당 머신 이미지안에는 Java 실행환경과 build Pipeline을 통해 만들어진 spring boot 앱이 포함되어 있습니다. 그러므로, 해당 머신 이미지를 기반으로 Azure VM Scale Set 인스턴스를 구성할 수 있습니다. </li></ol><h3 id="Azure-Virtual-Machine-Scale-Set에-이미지-업데이트"><a href="#Azure-Virtual-Machine-Scale-Set에-이미지-업데이트" class="headerlink" title="Azure Virtual Machine Scale Set에 이미지 업데이트"></a><strong>Azure Virtual Machine Scale Set에 이미지 업데이트</strong></h3><ol><li>   앞서서 생성한 머신 이미지를 이용하여 만들어진 Azure VM Scale Set 인스턴스에 포함된 Spring Boot 앱의 업데이트가 필요하다면, 앞선 절차의 Build/Release Pipeline을 통해서 머신 이미지를 다시 생성할 수 있으며 이를 기존의 Azure VM Scale Set의 인스턴스에 업데이트 해야 합니다.</li><li>   기존의 절차에 따라 새롭게 생성된 머신 이미지를 기존의 Azure VM Scale Set 인스턴스에 업데이트를 하기 위해 Release Pipeline에 Azure CLI Task를 추가합니다. </li></ol><ul><li>Azure CLI Task를 추가합니다.</li><li>   Azure Resource Manager Connection에 기존의 생성된 머신 이미지가 존재하는 Azure 리소스 그룹에 접근이 가능하도록 선택합니다. </li><li>   Script Type은 shell을 선택합니다.</li><li>   Script location은 inline Script를 선택합니다. </li><li>   Inline script에 아래를 추가합니다. (‘vms’는 VMSS의 이름, ‘vmss_rg’는 VMSS가 존재하는 resource group)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vmss update --name vms --resource-group vmss_rg --set virtualMachineProfile.storageProfile.imageReference.id=&quot;/subscriptions/&lt;subcscription-Id&gt;/resourceGroups/vmss_rg/providers/Microsoft.Compute/images/&lt;managed image name&gt;&quot;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>   새롭게 배포된 spring boot 앱을 이미지 업데이트 이후에 즉시 실행해야 한다면, 추가적으로 Azure CLI Task를 이용하여 원격에서 구동할 수 있습니다. </li></ol><ul><li>Azure CLI Task를 추가합니다. </li><li>앞선 Azure CLI task의 작업과 동일하며, inline script에 아래와 같이 다르게 입력합니다. <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vmss list-instances -n vms -g vmss_rg --query <span class="string">&quot;[].id&quot;</span> --output tsv | az vmss run-command invoke --scripts <span class="string">&quot;java -jar /lib/artifacts/spring-boot-complete-0.0.1-SNAPSHOT.jar &gt;/dev/null 2&gt;&amp;1 &amp;&quot;</span>  --command-id RunShellScript --ids @-</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>   모든 Pipeline이 정상적으로 실행 완료가 되면 새롭게 배포된 spring boot앱이 VMSS에 정상적으로 실행되는 지 확인하십시오.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;아래의 절차는 Azure DevOps에서 Azure Image Builder를 사용하는 과정을 참고하는 예제이며, 실제 업무상에 적용을 위해서는 많은 부분의 고려가 필요함을 미리 언급합니다. &lt;/p&gt;
&lt;p&gt;Azure DevOps에서 ‘Build </summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="QuickStart" scheme="https://kocssds.github.io/tags/QuickStart/"/>
    
    <category term="VMSS" scheme="https://kocssds.github.io/tags/VMSS/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps를 이용하여 Spring Boot 앱을 Linux VM에 배포하기</title>
    <link href="https://kocssds.github.io/2021/07/27/DeployAppToLinuxVM/"/>
    <id>https://kocssds.github.io/2021/07/27/DeployAppToLinuxVM/</id>
    <published>2021-07-27T12:37:58.000Z</published>
    <updated>2021-07-27T12:51:21.169Z</updated>
    
    <content type="html"><![CDATA[<p>다음은 Azure DevOps Pipeline을 이용하여 Spring Boot App을 Linux VM에 배포하는 시나리오의 예제입니다. Linux VM은 Azure DevOps의 Environments에 등록하여 구성합니다.</p><h3 id="Azure-환경에서-Linux-VM-생성"><a href="#Azure-환경에서-Linux-VM-생성" class="headerlink" title="Azure 환경에서 Linux VM 생성"></a><strong>Azure 환경에서 Linux VM 생성</strong></h3><ol><li>   Azure 포털에 로그온 합니다. </li><li>   좌측 메뉴에서 Create a resource에서 Virtual Machine을 생성합니다. </li><li>   Resource Group, Region그리고, Virtual Machine Name을 입력합니다. </li><li>   Image는 Ubuntu Server 18.04 LTS를 선택합니다. </li><li>   Inbound port rules에서 SSH(22) 포트를 오픈합니다. </li><li>   Review+Create를 통해 Linux VM을 생성합니다. </li><li>   생성시에 SSH key (.pem 파일)을 download 하는 데, 적당한 local folder에 저장합니다. 해당 키를 가지고, 해당 VM에 SSH로 접근할 수 있습니다. </li></ol><h3 id="Azure-DevOps-Repo의-구성"><a href="#Azure-DevOps-Repo의-구성" class="headerlink" title="Azure DevOps Repo의 구성"></a><strong>Azure DevOps Repo의 구성</strong></h3><ol><li>   Azure DevOps 포털에 로그온 합니다.</li><li>   New Project를 선택하여 새로운 Project를 생성합니다. </li><li>   생성된 Project로 들어가서 좌측의 Repos메뉴를 선택합니다. </li><li>   이후 Import a Repository 부분에서 사용하고자 하는 Spring Boot 예제를 import 하여 구성합니다. (예, <a href="https://github.com/spring-guides/gs-spring-boot.git">https://github.com/spring-guides/gs-spring-boot.git</a>  )</li></ol><h3 id="Azure-DevOps의-Environments에-Linux-VM-추가"><a href="#Azure-DevOps의-Environments에-Linux-VM-추가" class="headerlink" title="Azure DevOps의 Environments에 Linux VM 추가"></a><strong>Azure DevOps의 Environments에 Linux VM 추가</strong></h3><ol><li>   Azure DevOps 포털에 로그온 합니다. </li><li>   기 생성된 Project의 좌측 메뉴에서 Pipelines 하위의 Environments를 선택합니다. </li><li>   New environment를 선택합니다. </li><li>   New environment에서 Name(예, “linuxVM”)을 입력하여 Resource는 Virtual Machines를 선택합니다. </li><li>   Virtual machine resource에서 Provider는 Generic provider를 선택하고, OS는 Linux를 선택한 후 Registration script를 copy 합니다.</li><li>   앞서서 생성한 Linux VM에 SSH로 로그온 합니다. </li><li>   5번에서 copy 한 script를 paste 하여 실행합니다. </li><li>   정상적으로 script가 실행이 되었다면, Azure DevOps Environments에 4번에서 입력한 Name (예, “linuxVM”)으로 등록이 됩니다.</li><li>   추가적으로 SSH로 VM에 로그온 된 상태에서 “/lib/artifacts/” 폴더를 생성합니다. (해당 폴더는 Azure Pipeline을 통해서 배포된 Artifacts (jar 파일)를 copy 할 대상 폴더로 사용할 예정입니다.)</li><li>   Spring Boot App실행을 위해 Java Runtime Environment(JRE)를 설치합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y default-jre</span><br></pre></td></tr></table></figure></li></ol><h3 id="Linux-VM에서-추가-Port-오픈"><a href="#Linux-VM에서-추가-Port-오픈" class="headerlink" title="Linux VM에서 추가 Port 오픈"></a><strong>Linux VM에서 추가 Port 오픈</strong></h3><ol><li>   Azure 포털에서 이전 단계에서 생성한 VM 환경으로 들어갑니다.</li><li>   Settings의 Networking메뉴를 선택하고, 이후 Add Inbound Port Rule을 선택합니다.</li><li>   Source Port range는 “*”, Destination Port는 “8080”, Source 와 Destination을 둘 다 Any로 선택하고, TCP에 대해서 “Allow”로써 추가합니다.</li><li>   이후 TCP 8080 포트가 오픈 됩니다.</li></ol><h3 id="Azure-Pipeline의-구성"><a href="#Azure-Pipeline의-구성" class="headerlink" title="Azure Pipeline의 구성"></a><strong>Azure Pipeline의 구성</strong></h3><ol><li>   Environments에 Linux VM이 추가가 되었다면 다시 pipelines에서 New Pipeline을 선택합니다. </li><li>   Azure Repos Git을 선택하여 이전 단계에서 구성한 Repo를 선택합니다. </li><li>   Configure your pipeline 단계에서는 Repo에 구성된 소스를 컴파일하기 위해 Maven (build your java project and run tests with Apache Maven)을 선택합니다. </li><li>   프로젝트 내에 azure-pipelines.yml 파일이 자동 생성되고, 아래와 같이 내용을 추가합니다.<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">trigger:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pool:</span></span><br><span class="line">  <span class="attr">vmImage:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">stage:</span> <span class="string">Build</span></span><br><span class="line">    <span class="attr">displayName:</span> <span class="string">Build</span> <span class="string">Stage</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">displayName:</span> <span class="string">Build</span> <span class="string">Maven</span> <span class="string">Project</span></span><br><span class="line">        <span class="attr">steps:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">Maven@3</span></span><br><span class="line">            <span class="attr">displayName:</span> <span class="string">&#x27;Maven Package&#x27;</span></span><br><span class="line">            <span class="attr">inputs:</span></span><br><span class="line">              <span class="attr">mavenPomFile:</span> <span class="string">&#x27;complete/pom.xml&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">CopyFiles@2</span></span><br><span class="line">            <span class="attr">displayName:</span> <span class="string">&#x27;Copy Files to artifact staging directory&#x27;</span></span><br><span class="line">            <span class="attr">inputs:</span></span><br><span class="line">              <span class="attr">SourceFolder:</span> <span class="string">&#x27;$(System.DefaultWorkingDirectory)&#x27;</span></span><br><span class="line">              <span class="attr">Contents:</span> <span class="string">&#x27;**/target/*.?(war|jar)&#x27;</span></span><br><span class="line">              <span class="attr">TargetFolder:</span> <span class="string">$(Build.ArtifactStagingDirectory)</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">upload:</span> <span class="string">$(Build.ArtifactStagingDirectory)</span></span><br><span class="line">            <span class="attr">artifact:</span> <span class="string">drop</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">deployment:</span> <span class="string">DeployWeb</span></span><br><span class="line">      <span class="attr">displayName:</span> <span class="string">deploy</span> <span class="string">Web</span> <span class="string">App</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">vmImage:</span> <span class="string">&#x27;Ubuntu-latest&#x27;</span></span><br><span class="line">      <span class="comment"># creates an environment if it doesn&#x27;t exist</span></span><br><span class="line">      <span class="attr">environment:</span> </span><br><span class="line">       <span class="attr">name:</span> <span class="string">&#x27;linuxVM&#x27;</span></span><br><span class="line">       <span class="attr">resourceType:</span> <span class="string">VirtualMachine</span></span><br><span class="line">      <span class="attr">strategy:</span>        </span><br><span class="line">        <span class="attr">runOnce:</span></span><br><span class="line">          <span class="attr">deploy:</span></span><br><span class="line">            <span class="attr">steps:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">                sudo cp $(Pipeline.Workspace)/drop/**/target/*.jar /lib/artifacts/</span></span><br><span class="line"><span class="string">                sudo java -jar /lib/artifacts/*.jar &gt;/dev/null 2&gt;&amp;1 &amp;</span></span><br></pre></td></tr></table></figure></li><li>   Run 합니다. </li><li>   정상적으로 Azure Pipeline이 처리가 되었다면, Linux VM의 Public Ip를 통해 실행 중인 Spring Boot App을 접근할 수 있습니다. </li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;다음은 Azure DevOps Pipeline을 이용하여 Spring Boot App을 Linux VM에 배포하는 시나리오의 예제입니다. Linux VM은 Azure DevOps의 Environments에 등록하여 구성합니다.&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Linux" scheme="https://kocssds.github.io/tags/Linux/"/>
    
    <category term="QuickStart" scheme="https://kocssds.github.io/tags/QuickStart/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps를 이용하여 Spring Boot 앱을 Azure Virtual Machine Scale Set(VMSS)에 배포하기</title>
    <link href="https://kocssds.github.io/2021/07/22/DeployApptoVMSS/"/>
    <id>https://kocssds.github.io/2021/07/22/DeployApptoVMSS/</id>
    <published>2021-07-22T06:17:58.000Z</published>
    <updated>2021-07-22T07:05:44.118Z</updated>
    
    <content type="html"><![CDATA[<p>다음은 Azure DevOps Pipeline을 이용하여 간단한 Spring Boot 앱을 빌드하여 Azure Blob Storage에 배포한 후에 Custom Script Extension을 이용하여 VMSS에 해당 앱을 설치하는 과정을 단계별로 실습해 볼 수 있습니다. 아래의 단계는 업무에 사용될 수 있는 완벽한 예제는 아니며, VMSS에 Java 앱을 배포하는 여러가지 방법 중에 한가지 아이디어로써 참고하실 수 있습니다.</p><h3 id="Storage-Account의-생성"><a href="#Storage-Account의-생성" class="headerlink" title="Storage Account의 생성"></a><strong>Storage Account의 생성</strong></h3><hr><ol><li>   Azure 포털에 로그온 합니다. </li><li>   좌측 메뉴에서 Create Resource를 선택합니다.</li><li>   찾기에서 Storage Account찾아 선택합니다. </li><li>   생성 시, 새로운 resource group을 만들고, 임의의 Storage Account의 이름을 입력한 후, 적당한 Region을 선택하여 생성합니다. </li><li>   생성이 완료된 후, Storage Account로 들어가서 새로운 container를 추가합니다. </li><li>   Container 생성시, Public Access Level을 Blob으로 선택하여 생성합니다. </li></ol><h3 id="Azure-DevOps-Repo의-구성"><a href="#Azure-DevOps-Repo의-구성" class="headerlink" title="Azure DevOps Repo의 구성"></a><strong>Azure DevOps Repo의 구성</strong></h3><hr><ol><li>   Azure DevOps 포털에 로그온 합니다.</li><li>   New Project를 선택하여 새로운 Project를 생성합니다. </li><li>   생성된 Project로 들어가서 좌측의 Repos메뉴를 선택합니다. </li><li>   이후 Import a Repository 부분에서 사용하고자 하는 Spring Boot 예제를 import 하여 구성합니다. (예, <a href="https://github.com/spring-guides/gs-spring-boot.git">https://github.com/spring-guides/gs-spring-boot.git</a>  )</li></ol><h3 id="Azure-DevOps-Service-Connection-추가"><a href="#Azure-DevOps-Service-Connection-추가" class="headerlink" title="Azure DevOps Service Connection 추가"></a><strong>Azure DevOps Service Connection 추가</strong></h3><hr><ol><li>   이전 단계에서 생성된 Project의 Project settings에 들어갑니다.</li><li>   Service Connections에서 새로운 Service Connection을 생성합니다. </li><li>   New Service Connection에서 Azure Resource Manager를 선택합니다. </li><li>   Authentication Metod는 Service principal (automatic)을 선택한 후 다음을 누릅니다.</li><li>   Scope level은 Subscription으로 선택하고 Subscription, Resource Group(기존에 생성한 Resource Group을 선택) 그리고, Service Connection 이름을 입력하고 저장합니다.</li></ol><h3 id="Azure-DevOps-Pipeline의-구성"><a href="#Azure-DevOps-Pipeline의-구성" class="headerlink" title="Azure DevOps Pipeline의 구성"></a><strong>Azure DevOps Pipeline의 구성</strong></h3><hr><ol><li>   Project내에서Pipelines를 선택하고 Create Pipeline을 선택합니다.</li><li>   Azure Repos Git을 선택하여 이전 단계에서 구성한 Repo를 선택합니다. </li><li>   Configure your pipeline 단계에서는 Repo에 구성된 소스를 컴파일하기 위해 Maven (build your java project and run tests with Apache Maven)을 선택합니다. </li><li>   프로젝트 내에 azure-pipelines.yml 파일이 자동 생성되고, 아래와 같이 내용을 추가합니다.<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">trigger:</span></span><br><span class="line"><span class="bullet">-</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pool:</span></span><br><span class="line">  <span class="attr">vmImage:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">Maven@3</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">mavenPomFile:</span> <span class="string">&#x27;pom.xml&#x27;</span></span><br><span class="line">    <span class="attr">mavenOptions:</span> <span class="string">&#x27;-Xmx3072m&#x27;</span></span><br><span class="line">    <span class="attr">javaHomeOption:</span> <span class="string">&#x27;JDKVersion&#x27;</span></span><br><span class="line">    <span class="attr">jdkVersionOption:</span> <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">    <span class="attr">jdkArchitectureOption:</span> <span class="string">&#x27;x64&#x27;</span></span><br><span class="line">    <span class="attr">publishJUnitResults:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testResultsFiles:</span> <span class="string">&#x27;**/surefire-reports/TEST-*.xml&#x27;</span></span><br><span class="line">    <span class="attr">goals:</span> <span class="string">&#x27;package&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">CopyFiles@2</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&#x27;Copy Files to: $(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">SourceFolder:</span> <span class="string">&#x27;$(system.defaultworkingdirectory)&#x27;</span></span><br><span class="line">    <span class="attr">Contents:</span> <span class="string">&#x27;**/*.?(jar|sh)&#x27;</span></span><br><span class="line">    <span class="attr">TargetFolder:</span> <span class="string">&#x27;$(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">    <span class="attr">flattenFolders:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">condition:</span> <span class="string">succeededOrFailed()</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">PublishBuildArtifacts@1</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&#x27;Publish Artifact: drop&#x27;</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">PathtoPublish:</span> <span class="string">&#x27;$(build.artifactstagingdirectory)&#x27;</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">condition:</span> <span class="string">succeededOrFailed()</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">AzureCLI@2</span></span><br><span class="line">  <span class="attr">displayName:</span> <span class="string">&#x27;Azure CLI &#x27;</span></span><br><span class="line">  <span class="attr">inputs:</span></span><br><span class="line">    <span class="attr">azureSubscription:</span> <span class="string">&#x27;$(AZURE_SUBSCRIPTION)&#x27;</span></span><br><span class="line">    <span class="attr">scriptType:</span> <span class="string">bash</span></span><br><span class="line">    <span class="attr">scriptLocation:</span> <span class="string">inlineScript</span></span><br><span class="line">    <span class="attr">inlineScript:</span> <span class="string">&#x27;az storage blob upload-batch --destination artifacts --source $(build.artifactstagingdirectory) --account-name $AZURE_STORAGE_ACCOUNT&#x27;</span></span><br></pre></td></tr></table></figure></li><li>   Maven에 의해서 생성된 Task 외에 Copy Files, Publish Build Artifacts, 그리고, Azure CLI task를 차례로 추가합니다. 특히, Azure CLI task에서는 Maven Task에서 생성된 Artifacts를 지정된 Azure Blob Storage에 업로드를 합니다. </li><li>   Variables에 AZURE_SUBSCRIPTION과 AZURE_STORAGE_ACCOUNT를 추가하고, 앞서서 추가한 Service Connection과 Storage Account이름을 값으로 각각 입력합니다. </li><li>   Run합니다. </li><li>   문제가 없다면, Maven을 통해 생성된 (예를 들어, spring-boot-0.0.1-SNAPSHOT.jar) jar 파일이 지정된 Blob Storage에 업로드가 됩니다. </li></ol><h3 id="Shell-Script-파일의-추가"><a href="#Shell-Script-파일의-추가" class="headerlink" title="Shell Script 파일의 추가"></a><strong>Shell Script 파일의 추가</strong></h3><hr><ol><li>   Azure DevOps 포털에 로그온 합니다. </li><li>   이전 단계에서 생성한 Project 내의 Repos의 Files로 이동합니다. </li><li>   기존의 소스 폴더에 Shell Script 파일(.sh 파일)을 생성합니다.</li><li>   아래와 같이 내용을 추가합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">sudo apt-get update -y</span><br><span class="line">sudo apt-get install -y default-jre</span><br><span class="line">java -jar spring-boot-0.0.1-SNAPSHOT.jar &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li><li>   저장한 후 다시 build Pipeline을 Run 합니다.</li><li>   문제가 없다면, 지정된 Azure Blob Storage에 jar 파일과 더불어 .sh 파일이 업로드가 됩니다.</li></ol><h3 id="Azure-Virtual-Machine-Scale-Set-VMSS-의-구성"><a href="#Azure-Virtual-Machine-Scale-Set-VMSS-의-구성" class="headerlink" title="Azure Virtual Machine Scale Set (VMSS)의 구성"></a><strong>Azure Virtual Machine Scale Set (VMSS)의 구성</strong></h3><hr><ol><li>   Azure 포털에 로그온 합니다.</li><li>   좌측 메뉴에서 Create resource를 선택합니다.</li><li>   찾기 메뉴에서 Virtual Machine Scale Set을 찾아 선택합니다. </li><li>   생성시 기존에 생성한 Storage Account와 동일한 Resource Group을 선택합니다. </li><li>   Virtual Machine Scale Set name을 입력하고, Resource Group이 위치한 Region을 선택합니다. </li><li>   Ubuntu Server 20.04 LTS를 선택합니다. </li><li>   Networking에서 “Edit Network Interface”을 클릭하고, (간단한 Spring Boot 예제의 실행 테스트를 위해서) Public Ip Address를 enable 한 후 OK를 누릅니다. </li><li>   Management에서 Upgrade Policy는 Automatic으로 선택합니다.</li><li>   Review+Create를 선택하여 VMSS를 생성합니다. </li></ol><h3 id="Azure-Virtual-Machine-Scale-Set-VMSS-Port-오픈"><a href="#Azure-Virtual-Machine-Scale-Set-VMSS-Port-오픈" class="headerlink" title="Azure Virtual Machine Scale Set (VMSS) Port 오픈"></a><strong>Azure Virtual Machine Scale Set (VMSS) Port 오픈</strong></h3><hr><ol><li>   Azure 포털에서 이전 단계에서 생성한 VMSS 환경으로 들어갑니다.</li><li>   Settings의 Networking메뉴를 선택하고, 이후 Add Inbound Port Rule을 선택합니다.</li><li>   Source Port range는 “*”, Destination Port는 “8080”, Source 와 Destination을 둘 다 Any로 선택하고, TCP에 대해서 “Allow”로써 추가합니다.</li><li>   이후 TCP 8080 포트가 오픈됩니다.</li></ol><h3 id="Azure-DevOps의-Release-Pipeline구성"><a href="#Azure-DevOps의-Release-Pipeline구성" class="headerlink" title="Azure DevOps의 Release Pipeline구성"></a><strong>Azure DevOps의 Release Pipeline구성</strong></h3><hr><ol><li>   Azure DevOps 포털에 로그온 합니다.</li><li>   해당 Project로 들어가서 좌측의 Release 메뉴를 선택합니다. 이후 New Pipeline을 생성합니다. </li><li>   Empty Job을 선택합니다. </li><li>   Agent Job에서 Agent Specification을 ubuntu-20.04 로 선택합니다.</li><li>   Agent Job에 Azure CLI task를 추가합니다. </li><li>   Azure CLI task에서 Azure Resource Manager Connection은 이전 단계에서 생성한 Service Connection을 선택합니다. </li><li>   Script Type은Shell 로 선택합니다. </li><li>   Script Location은 inline script로 선택하고, 아래의 script를 추가합니다. <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vmss extension set --resource-group vmss_rg --vmss-name vmssmachines --name customScript --publisher Microsoft.Azure.Extensions --version 2.0 --extension-instance-name JarExt --settings &#x27;&#123;&quot;fileUris&quot;: [&quot;https://myvmssstorage.blob.core.windows.net/artifacts/deploy.sh&quot;, &quot;https://myvmssstorage.blob.core.windows.net/artifacts/spring-boot-0.0.1-SNAPSHOT.jar&quot;],&quot;commandToExecute&quot;: &quot;./deploy.sh&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure></li><li>   Create Release를 통해 deploy를 합니다. </li><li>   이전 Build Pipeline을 통해 업로드가 된 jar 파일과 shell script로 구성된 <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/extensions/custom-script-linux">Custom Script Extension</a>이 지정된 VMSS에 설치가 되고 Automatic Upgrade Policy에 의해 자동 업데이트가 됩니다.</li><li>   정상적으로 설치가 완료되면, VMSS에서 관리 중인 임의의 VM에 대한 지정된 Public IP와 8080 port를 이용해 Spring Boot 앱에 접근 테스트를 합니다. </li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;다음은 Azure DevOps Pipeline을 이용하여 간단한 Spring Boot 앱을 빌드하여 Azure Blob Storage에 배포한 후에 Custom Script Extension을 이용하여 VMSS에 해당 앱을 설치하는 과정을 단계별</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="QuickStart" scheme="https://kocssds.github.io/tags/QuickStart/"/>
    
    <category term="VMSS" scheme="https://kocssds.github.io/tags/VMSS/"/>
    
  </entry>
  
  <entry>
    <title>Azure Pipeline에서의 로그 확인</title>
    <link href="https://kocssds.github.io/2021/07/14/AzureDevOpsLogExtract/"/>
    <id>https://kocssds.github.io/2021/07/14/AzureDevOpsLogExtract/</id>
    <published>2021-07-14T05:10:37.000Z</published>
    <updated>2021-07-22T06:45:29.308Z</updated>
    
    <content type="html"><![CDATA[<p>Azure DevOps Pipeline에서 실패가 보고된다면, 가장 먼저 확인해야 하는 부분은 로그 부분일 것이다. </p><p><img src="/images/2021-07-14-14-19-10.png"></p><p>실패한 파이프라인을 클릭하고, 확인하고자 원하는 시간에 수행된 Build Pipeline을 선택하여 클릭한다.</p><p><img src="/images/2021-07-14-14-21-44.png"></p><p>그리고, 우측상단의 풀다운 메뉴를 크릭하면, 문제가 발생한 시점의 빌드 로그를 다운로드 받을 수 있다.</p><p><img src="/images/2021-07-14-14-23-39.png"></p><p>만일, Azure DevOps 측면에서 좀 더 자세한 로그 정보를 확인하길 원한다면, Build Pipeline의 Variables에 System.Debug 를 true로 설정하고 빌드를 시도한다면, 좀 더 자세한 로그를 출력할 수 있다. </p><p><img src="/images/2021-07-14-14-29-46.png"></p><p>더 많은 정보 확인: <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/troubleshooting/review-logs?view=azure-devops">Review logs to diagnose pipeline issues</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Azure DevOps Pipeline에서 실패가 보고된다면, 가장 먼저 확인해야 하는 부분은 로그 부분일 것이다. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2021-07-14-14-19-10.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;실패한 파이프라인을 클릭</summary>
      
    
    
    
    
    <category term="Azure DevOps" scheme="https://kocssds.github.io/tags/Azure-DevOps/"/>
    
    <category term="Build Pipeline" scheme="https://kocssds.github.io/tags/Build-Pipeline/"/>
    
  </entry>
  
</feed>
